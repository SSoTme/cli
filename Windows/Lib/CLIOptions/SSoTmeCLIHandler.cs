/*******************************************
 Initially Generated by SSoT.me - codee42 & odxml42
 Created By: EJ Alexandra - 2017
             An Abstract Level, llc
 License:    Mozilla Public License 2.0
 *******************************************/
using CLI;
using Plossum.CommandLine;
using SassyMQ.Lib.RabbitMQ;
using SassyMQ.SSOTME.Lib.RabbitMQ;
using SassyMQ.SSOTME.Lib.RMQActors;
using SSoTme.OST.Lib.DataClasses;
using SSoTme.OST.Lib.Extensions;
using SSoTme.OST.Lib.SassySDK.Derived;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Runtime.InteropServices;
using Newtonsoft.Json.Linq;
using System.Net.Http;
using SSoTme.OST.Core.Lib.Extensions;
using System.ComponentModel;
using Newtonsoft.Json;
using System.Net.Http.Json;
using SSoTme.OST.Lib.Services;

namespace SSoTme.OST.Lib.CLIOptions
{
    public class ProjectNotConfiguredException : Exception
    {
        public ProjectNotConfiguredException()
            : base("No ssotme project is configured in this directory.") { }
    }

    public class NoStackException : Exception
    {
        public NoStackException(string msg)
            : base(msg) { }
    }

    public partial class SSoTmeCLIHandler
    {
        // build scripts will make this match version from package.json
        public string CLI_VERSION = "2025.09.30.1831";
      
        private SSOTMEPayload result;
        private System.Collections.Concurrent.ConcurrentDictionary<string, byte> isTargetUrlProcessing = new System.Collections.Concurrent.ConcurrentDictionary<string, byte>();

        public SMQAccountHolder AccountHolder { get; private set; }
        public DMProxy CoordinatorProxy { get; private set; }


        private SSoTmeCLIHandler()
        {
            this.account = "";
            this.waitTimeout = 30000;
            this.input = new List<string>();
            this.OptionalInputCLIInputs = new List<string>();
            this.parameters = new List<string>();
            this.addSetting = new List<string>();
            this.removeSetting = new List<string>();
        }

        private SSoTmeProject GetProjectOrThrow()
        {
            if (this.AICaptureProject == null)
            {
                throw new ProjectNotConfiguredException();
            }
            return this.AICaptureProject;
        }

        public static SSoTmeCLIHandler CreateHandler(string commandLine)
        {
            var cliHandler = new SSoTmeCLIHandler();
            cliHandler.commandLine = commandLine;
            cliHandler.ParseCommand();
            return cliHandler;
        }


        public static SSoTmeCLIHandler CreateHandler(string[] args)
        {
            var cliOptions = new SSoTmeCLIHandler();
            cliOptions.args = args;
            cliOptions.ParseCommand();
            return cliOptions;
        }

        private void HandleInfoCommand()
        {
            try
            {
                var key = SSOTMEKey.GetSSoTmeKey(this.runAs);
                string runas = this.runAs;
                if (String.IsNullOrEmpty(runas))
                {
                    runas = "ssotme.key";
                }
                else
                {
                    runas += ".key";
                }
                Console.WriteLine($"\nSSoTme CLI Version {this.CLI_VERSION}\n\nConfiguration for `{runas}`:");
                Console.WriteLine($"Email Address: {key.EmailAddress}");
                Console.WriteLine($"Secret: {key.Secret}");

                // Display API keys if they exist
                if (key.APIKeys != null && key.APIKeys.Count > 0)
                {
                    Console.WriteLine("Configured API keys:");
                    foreach (var kvp in key.APIKeys)
                    {
                        Console.WriteLine($"  {kvp.Key}: {kvp.Value}");
                    }
                }
                else
                {
                    Console.WriteLine("No API keys configured.");
                }
            }
            catch (Exception e)
            {
                Console.WriteLine($"Error retrieving configuration: {e.Message}");
            }
        }

        private void HandleViewToolUrlCommand()
        {
            try
            {
                if (String.IsNullOrEmpty(this.viewToolUrl))
                {
                    Console.WriteLine("Error: Tool name is required. Usage: ssotme viewToolUrl <toolname>");
                    Console.WriteLine("To list all configured tools, use: ssotme listToolUrls");
                    return;
                }

                var url = this.TryGetUrlFromFileUrls(this.viewToolUrl);
                if (!String.IsNullOrEmpty(url))
                {
                    Console.WriteLine($"Tool '{this.viewToolUrl}' is configured with URL: {url}");
                }
                else
                {
                    Console.WriteLine($"Tool '{this.viewToolUrl}' is not configured in this project's SSoT/tool_urls.json file.");
                }
            }
            catch (Exception e)
            {
                Console.WriteLine($"Error retrieving tool URL: {e.Message}");
            }
        }

        private void ListAllConfiguredToolUrls()
        {
            try
            {
                var rootPath = FindProjectRoot();
                var toolUrlsPath = Path.Combine(rootPath, "SSoT", "tool_urls.json");

                if (!File.Exists(toolUrlsPath))
                {
                    Console.WriteLine("No tool URLs configured. The SSoT/tool_urls.json file does not exist.");
                    Console.WriteLine($"Use 'ssotme setToolUrl toolname=url' to configure tool URLs.");
                    return;
                }

                var jsonContent = File.ReadAllText(toolUrlsPath);
                var urlMappings = JsonConvert.DeserializeObject<Dictionary<string, string>>(jsonContent);

                if (urlMappings == null || !urlMappings.Any())
                {
                    Console.WriteLine("No tool URLs configured in SSoT/tool_urls.json.");
                    Console.WriteLine($"Use 'ssotme setToolUrl toolname=url' to configure tool URLs.");
                    return;
                }

                Console.WriteLine("Configured tool URLs:");
                Console.WriteLine();
                foreach (var kvp in urlMappings.OrderBy(x => x.Key))
                {
                    Console.WriteLine($"  {kvp.Key}: {kvp.Value}");
                }
                Console.WriteLine();
                Console.WriteLine($"Total: {urlMappings.Count} tool(s) configured");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error listing tool URLs: {ex.Message}");
            }
        }

        private string FindProjectRoot()
        {
            // If we have a loaded project, use its root path
            if (!ReferenceEquals(this.AICaptureProject, null))
            {
                return this.AICaptureProject.RootPath;
            }

            // Otherwise, search up the directory tree for project files
            var currentDir = new DirectoryInfo(Environment.CurrentDirectory);
            while (currentDir != null)
            {
                var projectFiles = new[] { "ssotme.json", "aicapture.json", "SSoTmeProject.json" };
                if (projectFiles.Any(file => File.Exists(Path.Combine(currentDir.FullName, file))))
                {
                    return currentDir.FullName;
                }
                currentDir = currentDir.Parent;
            }

            // If no project found, fall back to current directory
            return Environment.CurrentDirectory;
        }

        private void SetToolUrl(string toolName, string url)
        {
            try
            {
                var rootPath = FindProjectRoot();
                var toolUrlsPath = Path.Combine(rootPath, "SSoT", "tool_urls.json");

                // Ensure SSoT directory exists
                var ssotDir = Path.Combine(rootPath, "SSoT");
                if (!Directory.Exists(ssotDir))
                {
                    Directory.CreateDirectory(ssotDir);
                }

                // Load existing mappings or create new dictionary
                Dictionary<string, string> urlMappings;
                if (File.Exists(toolUrlsPath))
                {
                    var jsonContent = File.ReadAllText(toolUrlsPath);
                    urlMappings = JsonConvert.DeserializeObject<Dictionary<string, string>>(jsonContent) ?? new Dictionary<string, string>();
                }
                else
                {
                    urlMappings = new Dictionary<string, string>();
                }

                // Update or add the tool URL
                urlMappings[toolName] = url;

                // Save back to file
                var updatedJson = JsonConvert.SerializeObject(urlMappings, Formatting.Indented);
                File.WriteAllText(toolUrlsPath, updatedJson);
            }
            catch (Exception ex)
            {
                throw new Exception($"Error saving tool URL: {ex.Message}", ex);
            }
        }

        private void HandleSetToolUrlCommand()
        {
            try
            {
                if (String.IsNullOrEmpty(this.setToolUrl))
                {
                    Console.WriteLine("Error: Tool name and URL are required. Usage: ssotme -setToolUrl toolname=url");
                    return;
                }

                // Parse toolname=url format
                var parts = this.setToolUrl.Split('=');
                if (parts.Length != 2)
                {
                    Console.WriteLine("Error: Invalid format. Usage: ssotme -setToolUrl toolname=url");
                    return;
                }

                var toolName = parts[0].Trim();
                var url = parts[1].Trim();

                if (String.IsNullOrEmpty(toolName) || String.IsNullOrEmpty(url))
                {
                    Console.WriteLine("Error: Both tool name and URL must be specified. Usage: ssotme -setToolUrl toolname=url");
                    return;
                }

                // Add https:// if no protocol is specified
                if (!url.StartsWith("http://") && !url.StartsWith("https://"))
                {
                    url = "https://" + url;
                }

                this.SetToolUrl(toolName, url);
                Console.WriteLine($"Tool '{toolName}' URL set to: {url}");
            }
            catch (Exception e)
            {
                Console.WriteLine($"Error setting tool URL: {e.Message}");
            }
        }

        private void RemoveToolUrl(string toolName)
        {
            try
            {
                var rootPath = FindProjectRoot();
                var toolUrlsPath = Path.Combine(rootPath, "SSoT", "tool_urls.json");

                if (!File.Exists(toolUrlsPath))
                {
                    throw new Exception("No tool URLs file found. There are no configured tool URLs to remove.");
                }

                // Load existing mappings
                var jsonContent = File.ReadAllText(toolUrlsPath);
                var urlMappings = JsonConvert.DeserializeObject<Dictionary<string, string>>(jsonContent);

                if (urlMappings == null || !urlMappings.ContainsKey(toolName))
                {
                    throw new Exception($"Tool '{toolName}' is not configured in this project's tool URLs.");
                }

                // Remove the tool URL
                urlMappings.Remove(toolName);

                // Save back to file
                var updatedJson = JsonConvert.SerializeObject(urlMappings, Formatting.Indented);
                File.WriteAllText(toolUrlsPath, updatedJson);
            }
            catch (Exception ex)
            {
                throw new Exception($"Error removing tool URL: {ex.Message}", ex);
            }
        }

        private void HandleRemoveToolUrlCommand()
        {
            try
            {
                if (String.IsNullOrEmpty(this.removeToolUrl))
                {
                    Console.WriteLine("Error: Tool name is required. Usage: ssotme removeToolUrl <toolname>");
                    return;
                }

                var toolName = this.removeToolUrl.Trim();

                if (String.IsNullOrEmpty(toolName))
                {
                    Console.WriteLine("Error: Tool name must be specified. Usage: ssotme removeToolUrl <toolname>");
                    return;
                }

                this.RemoveToolUrl(toolName);
                Console.WriteLine($"Tool '{toolName}' URL has been removed from the project configuration.");
            }
            catch (Exception e)
            {
                Console.WriteLine($"Error removing tool URL: {e.Message}");
            }
        }

        private void ParseCommand()
        {
            try
            {
                CommandLineParser parser = new CommandLineParser(this);
                if (!String.IsNullOrEmpty(this.commandLine)) parser.Parse(this.commandLine, false);
                else parser.Parse(this.args, false);

                var remainingArguments = parser.RemainingArguments.ToList();
                this.FixParameters(ref remainingArguments);

                this.HasRemainingArguments = remainingArguments.Any();
                this.RemainingArguments = remainingArguments;

                bool continueToLoad = false;

                // If -g flag is used, prioritize remote transpiler naming regardless of transpiler arg
                if (!String.IsNullOrEmpty(this.targetUrl))
                {
                    this.transpiler = "remote-transpiler-" + this.targetUrl.SanitizeUrlForFilename();
                }
                else if (String.IsNullOrEmpty(this.transpiler))
                {
                    this.transpiler = remainingArguments.FirstOrDefault().SafeToString();

                    // First, try to get URL from tool_urls.json
                    var urlFromFile = this.TryGetUrlFromFileUrls(this.transpiler);
                    if (!String.IsNullOrEmpty(urlFromFile))
                    {
                        this.targetUrl = urlFromFile;
                        this.transpiler = "remote-transpiler-" + urlFromFile.SanitizeUrlForFilename();
                    }
                    else if (this.transpiler.Contains("/"))
                    {
                        if (!(Uri.TryCreate(this.transpiler, UriKind.Absolute, out var uriResult) &&
                            (uriResult.Scheme == Uri.UriSchemeHttp || uriResult.Scheme == Uri.UriSchemeHttps)))
                        {
                            // If this not a URL, assume it's a transpiler name with an account prefix
                            this.account = this.transpiler.Substring(0, this.transpiler.IndexOf("/"));
                            this.transpiler = this.transpiler.Substring(this.transpiler.IndexOf("/") + 1);
                        }
                        else
                        {
                            this.targetUrl = this.transpiler;
                            this.transpiler = "remote-transpiler-" + this.transpiler.SanitizeUrlForFilename();
                        }
                    }
                }
                else
                {
                    // If transpiler is already set but we also have a -g URL, check if we should still use remote naming
                    if (!String.IsNullOrEmpty(this.transpiler))
                    {
                        // First, try to get URL from tool_urls.json
                        var urlFromFile = this.TryGetUrlFromFileUrls(this.transpiler);
                        if (!String.IsNullOrEmpty(urlFromFile))
                        {
                            this.targetUrl = urlFromFile;
                            this.transpiler = "remote-transpiler-" + urlFromFile.SanitizeUrlForFilename();
                        }
                        else if (this.transpiler.Contains("/"))
                        {
                            if (Uri.TryCreate(this.transpiler, UriKind.Absolute, out var uriResult) &&
                                (uriResult.Scheme == Uri.UriSchemeHttp || uriResult.Scheme == Uri.UriSchemeHttps))
                            {
                                this.targetUrl = this.transpiler;
                                this.transpiler = "remote-transpiler-" + this.transpiler.SanitizeUrlForFilename();
                            }
                        }
                    }
                }

                var additionalArgs = remainingArguments.Skip(1).ToList();
                for (var i = 0; i < additionalArgs.Count; i++)
                {
                    this.parameters.Add(String.Format("param{0}={1}", i + 1, additionalArgs[i]));
                }

                if (this.help)
                {
                    var helpWidth = Console.WindowWidth - 4;
                    Console.WriteLine(parser.UsageInfo.GetHeaderAsString(helpWidth));
                    Console.WriteLine("\n\nSyntax: ssotme [account/]transpiler [Options]\n\n");
                    Console.WriteLine(parser.UsageInfo.GetOptionsAsString(helpWidth));
                    if (!this.noKey) Console.ReadKey();
                    this.SuppressTranspile = true;
                }
                else if (this.info)
                {
                    this.HandleInfoCommand();
                    continueToLoad = false;
                    this.SuppressTranspile = true;
                }
                else if (this.version)
                {
                    Console.WriteLine(this.CLI_VERSION);
                    this.SuppressTranspile = true;
                    this.SuppressKeyPress = true;
                    continueToLoad = false;
                }
                else if (this.init)
                {
                    if (String.IsNullOrEmpty(this.projectName))
                    {
                        this.projectName = Path.GetFileName(Environment.CurrentDirectory);
                    }
                    var force = this.args.Count() == 2 && this.args[1] == "force";
                    DataClasses.AICaptureProject.Init(force, this.projectName);
                    continueToLoad = true;
                    this.build = true;
                }
                else if (parser.HasErrors)
                {
                    var curColor = Console.ForegroundColor;
                    Console.ForegroundColor = ConsoleColor.Red;
                    Console.WriteLine(parser.UsageInfo.GetErrorsAsString(78));
                    this.ParseResult = -1;
                    Console.ForegroundColor = curColor;
                    this.SuppressTranspile = true;
                }
                else if (this.authenticate || this.discuss || this.listSeeds || this.cloneSeed || this.localGuide || !String.IsNullOrEmpty(this.viewToolUrl) || !String.IsNullOrEmpty(this.setToolUrl) || this.listToolUrls || !String.IsNullOrEmpty(this.removeToolUrl))
                {
                    continueToLoad = false;
                }
                else continueToLoad = true;

                // Check for api keys
                if (continueToLoad)
                {
                    if (String.IsNullOrEmpty(this.setAccountAPIKey) && !this.help && !this.authenticate && !this.listSeeds && !this.cloneSeed)
                    {
                        this.AICaptureProject = SSoTmeProject.LoadOrFail(new DirectoryInfo(Environment.CurrentDirectory), false, this.clean || this.cleanAll);
                        if (this.AICaptureProject is null) {
                            // warn user for clarity
                            ShowError("WARN: SSoTme project is null. Run `ssotme -init` to create a new one in this directory.", ConsoleColor.Yellow);
                        }

                        // still can continue with basic transpilers
                        foreach (var projectSetting in this.AICaptureProject?.ProjectSettings ?? new BindingList<ProjectSetting>())
                        {
                            if (!this.parameters.Any(anyParam => anyParam.StartsWith(String.Format("{0}=", projectSetting.Name))))
                            {
                                this.parameters.Add(String.Format("{0}={1}", projectSetting.Name, projectSetting.Value));
                            }
                        }
                    }

                    // Auto-build before loading input files if transpiler has -i dependencies
                    if (this.install && ShouldAutoBuildForInstall())
                    {
                        try
                        {
                            Console.WriteLine("Auto-building project before install (transpiler has -i file dependencies which don't exist)...");
                            // Ensure project is loaded first
                            if (this.AICaptureProject == null)
                            {
                                this.AICaptureProject = SSoTmeProject.LoadOrFail(new DirectoryInfo(Environment.CurrentDirectory), false, this.clean || this.cleanAll);
                            }
                            this.AICaptureProject?.Rebuild(Environment.CurrentDirectory, this.includeDisabled, this.transpilerGroup, this.buildOnTrigger, this.copilotConnect, this.buildLocal);
                            Console.WriteLine("Auto-build completed successfully.");
                        }
                        catch (Exception ex)
                        {
                            ShowError($"WARNING: Auto-build failed but continuing with install: {ex.Message}", ConsoleColor.Yellow);
                        }
                    }

                    this.LoadInputFiles();

                    var key = SSOTMEKey.GetSSoTmeKey(this.runAs);
                    if (key.APIKeys.ContainsKey(this.account))
                    {
                        this.parameters.Add(String.Format("apiKey={0}", key.APIKeys[this.account]));
                    }
                    if (!ReferenceEquals(this.FileSet, null))
                    {
                        this.ZFSFileSetFile = this.FileSet.FileSetFiles.FirstOrDefault(fodFileSetFile => fodFileSetFile.RelativePath.EndsWith(".zfs", StringComparison.OrdinalIgnoreCase));
                    }
                }
            }
            catch (Exception ex)
            {
                var curColor = Console.ForegroundColor;
                Console.ForegroundColor = ConsoleColor.Red;
                var currentException = ex;
                while (!(currentException is null))
                {
                    Console.WriteLine("\n********************************\nERROR: {0}\n********************************\n\n", currentException.Message);
                    Console.WriteLine(currentException.StackTrace);
                    if (!this.noKey) Console.WriteLine("\n\nPress any key to continue...\n");
                    Console.WriteLine("\n\n");
                    if (currentException == ex.InnerException) break;
                    currentException = ex.InnerException;
                }
                Console.ForegroundColor = curColor;
                this.SuppressTranspile = true;
                if (!this.noKey) Console.ReadKey();
            }
        }

        private GitRepo? ListSeeds(bool allowChoice, string requestedSeedName)
        {
            try
            {
                var publicRepos = GetPublicReposAsync("ssotme").GetAwaiter().GetResult();
                var allSeeds = publicRepos.Where(repo => repo.Name.Contains("seed"));
                var roots = allSeeds.Where(seed => seed.Name.Contains("root")).ToList();
                var seeds = allSeeds.Where(seed => !seed.Name.Contains("root")).ToList();

                // Set console window width to 90% of current width for wrapping
                int maxLineWidth = Math.Max((int)(Console.WindowWidth * 0.9) - 15, 60);

                Console.ResetColor();
                if (this.IsCurrentSeedRoot())
                {
                    if (!String.IsNullOrEmpty(requestedSeedName))
                    {
                        var selectedSeed = seeds.FirstOrDefault(fod => fod.Name.Equals(requestedSeedName, StringComparison.OrdinalIgnoreCase) ||
                                                                        fod.ShortName.Equals(requestedSeedName, StringComparison.OrdinalIgnoreCase));
                        if (selectedSeed is null) throw new Exception($"Requested seed not found: {requestedSeedName}");

                        return selectedSeed;
                    }
                    // Formatting for regular seeds
                    Console.ForegroundColor = ConsoleColor.Green; // Header in green
                    Console.WriteLine("\n\nPublic ssot.me starter seeds.");
                    Console.ResetColor();
                    return ListAndPickSeed(seeds, allowChoice, maxLineWidth);
                }
                else
                {
                    // Formatting for ROOT seeds
                    Console.ForegroundColor = ConsoleColor.Green; // Header in green
                    Console.WriteLine(@"Public ssot.me ROOT starter seeds.
These seeds are designed to connect to a specific data source, 
such as Airtable, MySQL, Postgress, GSheets, etc...

They typically include the schema, role based permissions,
documentation, along with other meta data about the datasource,
such as which tables have authorization data, email addresses,
roles, etc (if appropriate).
");

                    return ListAndPickSeed(roots, allowChoice, maxLineWidth);
                }
            }
            finally
            {
                // Footer text
                Console.ForegroundColor = ConsoleColor.White; // Default text color for the rest
                Console.WriteLine(@"
Go to https://github.com/ssotme for a current list of public Seeds available.

Syntax: 
     > ssotme -cloneseed https://github.com/ssotme/root-seed-mysql [seed-directory]\n\n\n");
                Console.ResetColor();
            }
        }

        private static GitRepo ListAndPickSeed(List<GitRepo> seeds, bool allowChoice, int maxLineWidth)
        {
            var selectedSeed = default(GitRepo);

            int seedNumber = 1;
            seeds.ForEach(seed =>
            {
                var seedName = seed.Name.Replace("root-", "");
                seedName = seedName.Replace("seed-", "");
                Console.ForegroundColor = ConsoleColor.Cyan; // Root seeds in cyan
                var seedSyntax1 = $"\n{seedNumber++} - {WrapText(seedName, maxLineWidth)}";
                seedSyntax1 += $"{"".PadLeft(Math.Max(0, 25 - seedSyntax1.Length))} > ssotme -cloneseed";
                var seedSyntax2 = $" {seedName} ";
                var seedSyntax3 = $"my-{seedName}";
                var lines = $"{WrapText(seed.Description, maxLineWidth)}".Split(Environment.NewLine).ToList();
                var description = String.Join(",\n", lines.Select(str => $"{"".PadRight(27)}{str}"));

                Console.Write($"{seedSyntax1}");
                Console.ForegroundColor = ConsoleColor.Blue; // Root seeds in cyan
                Console.Write($"{seedSyntax2}");
                Console.ForegroundColor = ConsoleColor.Cyan; // Root seeds in cyan
                Console.WriteLine($"{seedSyntax3}");
                Console.WriteLine($"{description}");
                Console.WriteLine();
                Console.ResetColor();
            });

            if (allowChoice)
            {
                Console.Write("Enter the number of the seed to clone here: ");
                var readLn = Console.ReadLine();
                if (Int32.TryParse(readLn, out int rootSeedSelected))
                {
                    selectedSeed = seeds[rootSeedSelected - 1];
                }
            }
            return selectedSeed;
        }

        private bool IsCurrentSeedRoot()
        {
            var ssotmeFile = new FileInfo("ssotme.json");

            // Check if the ssotme.json file exists in the current directory
            if (!ssotmeFile.Exists) return false;

            try
            {
                // Parse the JSON content of the ssotme.json file
                var jsonContent = File.ReadAllText(ssotmeFile.FullName);
                var project = JObject.Parse(jsonContent);

                // Access the Transpilers array and check if any of the transpiler groups match "ssot"
                var transpilers = project["ProjectTranspilers"] as JArray;
                if (transpilers != null)
                {
                    return transpilers.Any(tp =>
                        string.Equals((string)tp["TranspilerGroup"], "ssot", StringComparison.OrdinalIgnoreCase));
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error parsing ssotme.json: {ex.Message}");
            }
            return false;
        }

        // Helper function to wrap text to the specified width
        private static string WrapText(string text, int maxWidth)
        {
            if (string.IsNullOrEmpty(text) || text.Length <= maxWidth) return text;
            var lines = new List<string>();
            var words = text.Split(' ');
            var currentLine = string.Empty;
            foreach (var word in words)
            {
                if ((currentLine.Length + word.Length + 1) > maxWidth)
                {
                    lines.Add(currentLine);
                    currentLine = word;
                }
                else
                {
                    currentLine += (currentLine.Length > 0 ? " " : "") + word;
                }
            }
            lines.Add(currentLine); // Add the last line
            return string.Join(Environment.NewLine, lines);
        }

        public class GitRepo
        {
            public string Name { get; set; }
            public string Description { get; set; }
            public string ShortName => $"{this.Name}".Replace("root-", "").Replace("seed-", "");
            public string Url { get => $"https://github.com/ssotme/{this.Name}"; }
        }

        public static async Task<List<GitRepo>> GetPublicReposAsync(String account)
        {
            var apiUrl = $"https://api.github.com/users/{account}/repos";
            var reposList = new List<GitRepo>();
            using (var client = new HttpClient())
            {
                client.DefaultRequestHeaders.Add("User-Agent", "request"); // GitHub API requires a user-agent header
                try
                {
                    var response = await client.GetStringAsync(apiUrl);
                    JArray repos = JArray.Parse(response);
                    foreach (JObject repo in repos)
                    {
                        string name = repo["name"].ToString();
                        string description = repo["description"].ToString();
                        var repoMetaData = new GitRepo() { Name = name, Description = description };
                        reposList.Add(repoMetaData);
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error fetching repository data: {ex.Message}");
                    // Optionally, handle exceptions in a way that suits your application's needs
                }
            }
            reposList.Add(new GitRepo() { Name = "seed-airtable-dotnet-api", Description = "An EffortlessAPI for Airtable Dotnet REST-API, Swagger documentation." });
            reposList.Add(new GitRepo() { Name = "seed-golang-dotnet-api", Description = "An EffortlessAPI for Airtable Golang REST-API, Swagger documentation." });
            return reposList;
        }

        private async Task<string> CloneSeed(GitRepo seedRepo)
        {
            string seedRepoUrl = seedRepo?.Url;
            seedRepoUrl = seedRepoUrl ?? this.GetSeedUrl();
            string initialDirectoryName = this.RemainingArguments.FirstOrDefault();
            return seedRepo.CloneRepositoryUsingCmd(initialDirectoryName);
        }

        private string _cachedSeedUrl;

        private string GetSeedUrl()
        {
            if (String.IsNullOrEmpty(this._cachedSeedUrl))
            {
                var seedRepoUrl = this.RemainingArguments.FirstOrDefault();
                if (String.IsNullOrEmpty(seedRepoUrl))
                {
                    Console.Write(@"Please enter the git url for the seed repository that you would like to clone.  Press ENTER to abort.
eg: https://github.com/your-account/your-seed.git
or: git@github.com:your-account/your-seed

Seed Url: ");
                    seedRepoUrl = Console.ReadLine();
                }
                else RemainingArguments.RemoveAt(0);
                _cachedSeedUrl = seedRepoUrl;
            }
            return _cachedSeedUrl;
        }

        private void FixParameters(ref List<string> additionalArgs)
        {
            var cmd = additionalArgs.FirstOrDefault();
            switch ($"{cmd}".ToLower())
            {
                case "init":
                    this.init = true;
                    break;

                case "help":
                    this.help = true;
                    break;

                case "install":
                    this.install = true;
                    break;

                case "cloneseed":
                case "clone":
                    this.cloneSeed = true;
                    break;
                
                case "dryRun":
                    this.dryRun = true;
                    break;

                case "listseeds":
                    this.listSeeds = true;
                    break;

                case "build":
                case "buildLocal":
                case "rebuild":
                case "pull":
                    this.build = true;
                    break;

                case "buildall":
                case "rebuildall":
                case "pullAll":
                    this.buildAll = true;
                    break;

                case "clean":
                    this.clean = true;
                    break;

                case "cleanall":
                    this.cleanAll = true;
                    break;

                case "describe":
                    this.describe = true;
                    break;

                case "descibeAll":
                    this.descibeAll = true;
                    break;

                case "localguide":
                case "lg":
                    this.localGuide = true;
                    break;

                case "listtoolurls":
                case "lt":
                    this.listToolUrls = true;
                    break;

                case "viewtoolurl":
                case "vt":
                    this.viewToolUrl = additionalArgs.Skip(1).FirstOrDefault() ?? "";
                    break;

                case "settoolurl":
                case "st":
                    this.setToolUrl = additionalArgs.Skip(1).FirstOrDefault();
                    break;

                case "removetoolurl":
                case "rt":
                    this.removeToolUrl = additionalArgs.Skip(1).FirstOrDefault();
                    break;

                case "version":
                case "v":
                    this.version = true;
                    break;

                case "info":
                    this.info = true;
                    break;

                default:
                    return;
            }

            this.transpiler = additionalArgs.Skip(1).FirstOrDefault();
            if (additionalArgs.Count > 0) additionalArgs.RemoveAt(0);
        }

        public int TranspileProject(ProjectTranspiler projectTranspiler = null)
        {
            bool updateProject = false;
            try
            {
                var hasRemainingArguments = this.HasRemainingArguments;
                var zfsFileSetFile = this.ZFSFileSetFile;
                if (this.authenticate)
                {
                    var effortlessAPIService = new MyEffortlessAPIService();
                    effortlessAPIService.HandleAuth().Wait();
                    this.SuppressTranspile = true;
                    this.SuppressKeyPress = true;
                    return 0;
                }
                else if (this.localGuide)
                {
                    var effortlessAPIService = new MyEffortlessAPIService();
                    
                    // Get project name from transpiler argument or current directory
                    string projectName = this.transpiler;
                    if (string.IsNullOrEmpty(projectName))
                    {
                        // Try to infer project name from current directory
                        projectName = Path.GetFileName(Environment.CurrentDirectory);
                        Console.WriteLine($"No project name specified, using current directory: {projectName}");
                    }
                    
                    effortlessAPIService.HandleLocalGuide(projectName).Wait();
                    this.SuppressTranspile = true;
                    this.SuppressKeyPress = true;
                    return 0;
                }
                else if (this.describe)
                {
                    GetProjectOrThrow().Describe(Environment.CurrentDirectory);
                }
                else if (this.descibeAll)
                {
                    GetProjectOrThrow().Describe();
                }
                else if (this.listSettings)
                {
                    GetProjectOrThrow().ListSettings();
                }
                else if (this.addSetting.Any())
                {
                    foreach (var setting in this.addSetting)
                    {
                        GetProjectOrThrow().AddSetting(setting);
                    }

                    this.AICaptureProject.Save();
                }
                else if (this.listSeeds)
                {
                    this.ListSeeds(false, null);
                    this.SuppressTranspile = true;
                }
                else if (this.cloneSeed)
                {
                    this.InitiateCloneSeedingProcess();
                    this.SuppressTranspile = true;
                }
                else if (!String.IsNullOrEmpty(this.viewToolUrl))
                {
                    this.HandleViewToolUrlCommand();
                    this.SuppressTranspile = true;
                }
                else if (!String.IsNullOrEmpty(this.setToolUrl))
                {
                    this.HandleSetToolUrlCommand();
                    this.SuppressTranspile = true;
                }
                else if (this.listToolUrls)
                {
                    this.ListAllConfiguredToolUrls();
                    this.SuppressTranspile = true;
                }
                else if (!String.IsNullOrEmpty(this.removeToolUrl))
                {
                    this.HandleRemoveToolUrlCommand();
                    this.SuppressTranspile = true;
                }
                else if (this.removeSetting.Any())
                {
                    foreach (var setting in this.removeSetting)
                    {
                        GetProjectOrThrow().RemoveSetting(setting);
                    }
                    this.AICaptureProject.Save();
                }
                else if (!String.IsNullOrEmpty(this.setAccountAPIKey))
                {
                    var key = SSOTMEKey.GetSSoTmeKey(this.runAs);
                    if (ReferenceEquals(key.APIKeys, null)) key.APIKeys = new Dictionary<String, String>();
                    var apiKey = this.setAccountAPIKey.SafeToString().Replace("=", "/");
                    var values = apiKey.Split("/".ToCharArray());

                    if (values[0].Equals("baserow", StringComparison.OrdinalIgnoreCase))
                    { // special case for baserow, where we need the username and password
                        // -setAccountAPIKey=baserow/username/password
                        if (values.Length < 3)
                        {
                            ShowError("Syntax for \"baserow\": -setAccountAPIKey=baserow/username/password");
                            return -1;
                        }

                        var baserowConf = new { username = values[1], password = values[2] };
                        key.APIKeys["baserow"] = JsonConvert.SerializeObject(baserowConf);
                    }
                    else
                    {
                        if (!values.Skip(1).Any())
                        {
                            ShowError("Default Syntax: -setAccountAPIKey=account/KEY");
                            return -1;
                        }
                        key.APIKeys[values[0]] = values[1];
                    }
                    SSOTMEKey.SetSSoTmeKey(key, this.runAs);
                }
                else if (this.install && this.transpiler.StartsWith("remote-transpiler"))
                {
                    result = new SSOTMEPayload()
                    {
                        Transpiler = new Transpiler()
                        {
                            Name = this.transpiler,
                        }
                    };
                    this.AICaptureProject.Install(result, this.transpilerGroup, this.dryRun);
                }
                else if (!String.IsNullOrEmpty(this.execute))
                {
                    this.ProcessCommandLine(this.execute);
                    if (this.install)
                    {
                        result = new SSOTMEPayload()
                        {
                            Transpiler = new Transpiler()
                            {
                                Name = "-execute"
                            }
                        };
                        this.AICaptureProject.Install(result, this.transpilerGroup, this.dryRun);
                    }
                }
                else if (this.build || this.buildLocal)
                {
                    GetProjectOrThrow().Rebuild(Environment.CurrentDirectory, this.includeDisabled, this.transpilerGroup, this.buildOnTrigger, this.copilotConnect, this.buildLocal);
                }
                else if (this.buildAll)
                {
                    GetProjectOrThrow().RebuildAll(this.AICaptureProject.RootPath, this.includeDisabled, this.transpilerGroup, this.buildOnTrigger, this.copilotConnect, this.buildLocal);
                }
                else if (this.discuss)
                {
                    var aicManager = AICManager.Create(this.Auth0SID);
                    aicManager.Start();
                }
                else if (this.checkResults || this.createDocs && !hasRemainingArguments)
                {
                    GetProjectOrThrow().CreateDocs(this.checkResults);
                    updateProject = true;
                }
                else if (this.clean && !ReferenceEquals(zfsFileSetFile, null))
                {
                    var possiblyOptionalFileName = zfsFileSetFile.RelativePath;
                    var zfsFI = new FileInfo(possiblyOptionalFileName);
                    if (zfsFI.Exists)
                    {
                        var zippedFileSet = File.ReadAllBytes(zfsFI.FullName);
                        zippedFileSet.CleanZippedFileSet();
                        if (!this.preserveZFS) zfsFI.Delete();
                    }
                }
                else if (this.clean && !hasRemainingArguments)
                {
                    this.AICaptureProject?.Clean(Environment.CurrentDirectory, this.preserveZFS);
                    Task.Run(() => new DirectoryInfo(Environment.CurrentDirectory).ApplySeedReplacementsAsync(true)).Wait();

                }
                else if (this.cleanAll && !hasRemainingArguments)
                {
                    this.AICaptureProject?.CleanAll(this.preserveZFS);
                    Task.Run(() => new DirectoryInfo(Environment.CurrentDirectory).ApplySeedReplacementsAsync(true)).Wait();
                }
                else if (!hasRemainingArguments && !this.clean && String.IsNullOrEmpty(this.targetUrl) && this.viewToolUrl == null && String.IsNullOrEmpty(this.setToolUrl) && !this.listToolUrls && String.IsNullOrEmpty(this.removeToolUrl))
                {
                    ShowError("Missing argument name of transpiler");
                    return -1;
                }
                else
                {
                    StartTranspile();

                    if (!ReferenceEquals(result.Exception, null))
                    {
                        var nextException = result.Exception;
                        while (!(nextException is null))
                        {
                            ShowError("ERROR: " + nextException.Message);
                            ShowError(nextException.StackTrace);
                            nextException = nextException.InnerException;
                        };
                        return -1;
                    }
                    else
                    {
                        var finalResult = 0;

                        if (!ReferenceEquals(result.Transpiler, null))
                        {
                            //Console.WriteLine("\n\nTRANSPILER MATCHED: {0}\n\n", result.Transpiler.Name);
                        }

                        if (this.clean) result.CleanFileSet();
                        else
                        {
                            finalResult = result.SaveFileSet(this.skipClean);
                            updateProject = true;
                        }
                        return finalResult;

                    }
                }

                return 0;
            }
            finally
            {
                if (!ReferenceEquals(AccountHolder, null)) AccountHolder.Disconnect();
                if (updateProject)
                {
                    if (this.install) this.AICaptureProject.Install(result, this.transpilerGroup, this.dryRun);
                    else if (!ReferenceEquals(projectTranspiler, null))
                    {
                        GetProjectOrThrow().Update(projectTranspiler, result);
                    }
                }
            }
        }

        private void InitiateCloneSeedingProcess()
        {
            var requestedSeedName = this.RemainingArguments.FirstOrDefault();
            var seed = this.ListSeeds(true, requestedSeedName);
            if (seed is null) return;
            string seedRootPath = default;
            var task = Task.Run(async () => seedRootPath = await this.CloneSeed(seed));
            task.Wait(300000);
            if (!task.IsCompleted || !(task.Exception is null)) throw new Exception($"Unable to clone repo {task.Exception.Message}", task.Exception);
            var seedDI = new DirectoryInfo(seedRootPath);
            seedDI.CheckSSoTmeCache(seed.Name);
            seedDI.InvokeSSoTmeBuild();
            seedDI.StartSeedBuild();
        }

        private bool CheckAuthenticationNow()
        {
            Console.WriteLine("Authenticating with auth0.");
            if (!String.IsNullOrEmpty(this.Auth0SID))
            {
                this.PrintAuth();
                Console.WriteLine("Already authenticated.  Reauthenticate now? y/N");
                if (Console.ReadKey().Key != ConsoleKey.Y) return true;
            }

            var startInfo = new ProcessStartInfo();
            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
            {
                startInfo.FileName = "cmd";
                startInfo.Arguments = $"/c start chrome {this.AICaptureHost}/cli-login";
            }
            else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
            {
                startInfo.FileName = "xdg-open";
                startInfo.Arguments = $"{this.AICaptureHost}/cli-login";
            }
            else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
            {
                startInfo.FileName = "open";
                startInfo.Arguments = $"{this.AICaptureHost}/cli-login";
            }
            else
            {
                throw new InvalidOperationException("Unsupported operating system");
            }

            startInfo.UseShellExecute = false;
            startInfo.RedirectStandardInput = true;
            startInfo.CreateNoWindow = true;

            var process = new Process { StartInfo = startInfo };
            process.Start();
            process.StandardInput.Close();

            var result = LocalServer.StartServerAsync("http://localhost:8080/complete-cli/");
            result.Wait(300000);
            if (result.IsCompleted)
            {
                object jwtFromRedirect = $"result: {result.Result}";
                this.Auth0SID = result.Result;
                this.PrintAuth();
                return true;
            }
            else
            {
                ShowError("Syntax: ssotme unable to authenticate within the specified timeout period.");
                return false;
            }
        }

        private void PrintAuth()
        {
            var webClient = new WebClient();
            var payload = $"{{ \"Auth0SID\":\"{this.Auth0SID}\" }}";
            var resultBytes = webClient.UploadData($"{this.AICaptureHost}/whoami", Encoding.UTF8.GetBytes(payload));
            var jwt = Encoding.UTF8.GetString(resultBytes);
            Console.WriteLine(jwt);
        }

        private void PublicUser_ReplyTo(object sender, PayloadEventArgs<SSOTMEPayload> e)
        {
            if (e.Payload.IsLexiconTerm(LexiconTermEnum.publicuser_ping_ssotmecoordinator))
            {
                this.CoordinatorProxy = new DMProxy(e.Payload.DirectMessageQueue);
                var payload = this.PublicUser.CreatePayload();
                throw new Exception("This: payload.EmailAddress = this.emailAddress; isn't really a thing anymore.");
                this.PublicUser.PublicUserAuthenticate(payload, this.CoordinatorProxy);
            }
            else if (e.Payload.IsLexiconTerm(LexiconTermEnum.publicuser_authenticate_ssotmecoordinator))
            {
                Console.WriteLine("We sent an auth key to {0}.", e.Payload.EmailAddress);
                Console.Write("AUTH Code: ");
                e.Payload.AuthToken = Console.ReadLine();
                if (!String.IsNullOrEmpty(e.Payload.AuthToken))
                {
                    Console.WriteLine("Validating AUTH Code.  One moment...");
                    this.PublicUser.PublicUserValidateAuthToken(e.Payload, this.CoordinatorProxy);
                }
                else
                {
                    Console.WriteLine("Aborting. No AUTH Code recieved.");
                }
            }
            else if (e.Payload.IsLexiconTerm(LexiconTermEnum.publicuser_validateauthtoken_ssotmecoordinator))
            {
                if (String.IsNullOrEmpty(e.Payload.Secret))
                {
                    Console.WriteLine("AUTH Code Validated Failed.");
                }
                else
                {
                    Console.WriteLine("AUTH Code Validated.");
                    try
                    {
                        var key = SSOTMEKey.GetSSoTmeKey(this.account);
                        key.EmailAddress = e.Payload.EmailAddress;
                        key.Secret = e.Payload.Secret;
                        SSOTMEKey.SetSSoTmeKey(key, this.account);
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine("ERROR: {0}", ex.Message);
                    }
                }
                Console.WriteLine("Press enter to continue.");
                Console.ReadLine();
                this.PublicUser.Disconnect();
            }
        }

        private static void ShowError(string msg, ConsoleColor color = ConsoleColor.Red)
        {
            var curColor = Console.ForegroundColor;
            Console.ForegroundColor = color;
            Console.WriteLine(msg);
            Console.ForegroundColor = curColor;
        }

        private string TryGetUrlFromFileUrls(string transpilerName)
        {
            try
            {
                var rootPath = FindProjectRoot();
                var toolUrlsPath = Path.Combine(rootPath, "SSoT", "tool_urls.json");
                if (!File.Exists(toolUrlsPath))
                {
                    return null;
                }
                var jsonContent = File.ReadAllText(toolUrlsPath);
                var urlMappings = JsonConvert.DeserializeObject<Dictionary<string, string>>(jsonContent);
                if (urlMappings != null && urlMappings.ContainsKey(transpilerName))
                {
                    return urlMappings[transpilerName];
                }
            }
            catch (Exception ex)
            {
                // Log the error but don't fail the entire operation
                Console.WriteLine($"Warning: Error reading SSoT/tool_urls.json: {ex.Message}");
            }
            return null;
        }

        private void ProcessCommandLine(string commandLine)
        {
            var cmd = $"{commandLine} ";
            var executable = cmd.Substring(0, cmd.IndexOf(" "));
            var args = cmd.Substring(executable.Length + 1);
            var psi = new ProcessStartInfo(executable, args);
            try
            {
                var process = Process.Start(psi);
                process.WaitForExit(this.waitTimeout);
                if (!process.HasExited)
                {
                    process.Close();
                    throw new NoStackException(String.Format("Timed out waiting for process to complete: {0}", commandLine));
                }
            }
            catch (System.ComponentModel.Win32Exception ex)
            {
                throw new NoStackException($"The system couldn't find the command \"{executable}\"");
            }
        }

        internal void LoadOutputFiles(String lowerHyphoneName, String basePath, bool includeContents)
        {
            var rootPath = ReferenceEquals(this.AICaptureProject, null) ? Environment.CurrentDirectory : this.AICaptureProject.RootPath;
            var zfsRelativePath = String.Format("{0}.zfs", lowerHyphoneName);
            basePath = basePath.Trim("\\/".ToCharArray());
            var zfsFileName = Path.Combine(rootPath, ".ssotme", basePath, zfsRelativePath);

            var zfsFI = new FileInfo(zfsFileName);
            if (zfsFI.Exists)
            {
                var fileSetXml = File.ReadAllBytes(zfsFI.FullName).UnzipToString();
                var fs = fileSetXml.ToFileSet();
                foreach (var fsf in fs.FileSetFiles)
                {
                    var relativePath = fsf.RelativePath.Trim("\\/\r\n\t ".ToCharArray());
                    fsf.OriginalRelativePath = Path.Combine(basePath, relativePath).Replace("\\", "/");
                    if (!includeContents) fsf.ClearContents();
                }
                this.OutputFileSet = fs;
            }
        }

        private void StartTranspile()
        {
            this.AccountHolder = new SMQAccountHolder();
            var currentSSoTmeKey = SSOTMEKey.GetSSoTmeKey(this.runAs);
            result = null;

            //this.AccountHolder.ReplyTo += AccountHolder_ReplyTo;
            this.AccountHolder.Init("cli@aicapture.io", "e8f398c3c1854bf7b9b0deb123ba0127");
            this.ProxyRequest();

            var waitForCook = Task.Factory.StartNew(() =>
            {
                while (ReferenceEquals(result, null)) Thread.Sleep(100);
            });

            waitForCook.Wait(this.waitTimeout);

            if (ReferenceEquals(result, null))
            {
                result = AccountHolder.CreatePayload();
                result.Exception = new TimeoutException("Timed out waiting for cook");
            }
            result.SSoTmeProject = this.AICaptureProject;
        }

        public string inputFileContents = "";
        public string transpiler = "";
        public string inputFileSetXml;
        public string[] args;
        public string commandLine;
        private SMQPublicUser PublicUser;
        public string inputFileSetJson;

        public FileSet FileSet { get; private set; }
        public bool HasRemainingArguments { get; private set; }
        public List<string> RemainingArguments { get; private set; }
        public FileSetFile ZFSFileSetFile { get; private set; }
        public SSoTmeProject AICaptureProject { get; set; }
        public int ParseResult { get; private set; }
        public FileSet OutputFileSet { get; private set; }
        public bool SuppressTranspile { get; private set; }
        public bool SuppressKeyPress { get; private set; }

        public string AICaptureHost
        {
            get
            {
#if DEBUG
                return "https://localhost:7033";
#else
                return "https://aicapture.io";
#endif
            }
        }
        public string Auth0SID
        {
            get
            {
                if (Auth0TokenFI.Exists) return File.ReadAllText(Auth0TokenFI.FullName);
                else return String.Empty;
            }
            set
            {
                File.WriteAllText(Auth0TokenFI.FullName, value);
            }
        }

        private static FileInfo Auth0TokenFI
        {
            get
            {
                var auth0TokenPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), ".aicapture", "auth0.key");
                var auth0TokenFI = new FileInfo(auth0TokenPath);
                if (!auth0TokenFI.Directory.Exists) auth0TokenFI.Directory.Create();
                return auth0TokenFI;
            }
        }

        public List<string> OptionalInputCLIInputs { get; internal set; }
        private void SaveOptionalCLIInputs()
        {
            this.OptionalInputCLIInputs = this.OptionalInputCLIInputs ?? new List<string>();
            var inputFileCount = this.input is null ? 0 : input.Count();
            for (int fileIndex = 0; fileIndex < inputFileCount; fileIndex++)
            {
                var inputFileName = input[fileIndex];
                if ((inputFileName ?? "").EndsWith("?"))
                {
                    var concreteFileName = inputFileName.TrimEnd('?');
                    input[inputFileCount] = concreteFileName;
                    this.OptionalInputCLIInputs.Add(concreteFileName);
                }
            }
        }


        public void LoadInputFiles()
        {
            this.SaveOptionalCLIInputs();
            var fs = new FileSet();
            if (!ReferenceEquals(this.input, null) && this.input.Any())
            {
                foreach (var input in this.input)
                {
                    if (!String.IsNullOrEmpty(input))
                    {
                        var inputFilePatterns = input.Split(",".ToCharArray(), StringSplitOptions.RemoveEmptyEntries);
                        foreach (var filePattern in inputFilePatterns)
                        {
                            this.ImportFile(filePattern, fs);
                        }

                        if (fs.FileSetFiles.Any()) this.inputFileContents = fs.FileSetFiles.First().FileContents;

                    }
                }
            }
            this.inputFileSetXml = fs.ToXml();
            this.FileSet = fs;
        }

        /// <summary>
        /// Validates that a file path is within the project scope.
        /// Throws NoStackException if the path attempts to access files outside the project.
        /// </summary>
        /// <param name="filePath">The file path to validate</param>
        /// <param name="projectRoot">The project root directory (optional)</param>
        private void ValidatePathIsInProjectScope(string filePath, string projectName, string projectRoot = null)
        {
            // If no project is loaded, we can't validate scope - allow the operation
            // This handles cases like -init, -listSeeds, etc. that don't need a project
            if (String.IsNullOrEmpty(projectRoot))
            {
                return;
            }

            try
            {
                // Resolve both paths to absolute paths to handle .. and symlinks
                var absoluteProjectRoot = Path.GetFullPath(projectRoot);
                var absoluteFilePath = Path.GetFullPath(Path.Combine(Environment.CurrentDirectory, filePath));

                // Check if the file path starts with the project root
                // Use case-insensitive comparison for Windows compatibility
                if (!absoluteFilePath.StartsWith(absoluteProjectRoot, StringComparison.OrdinalIgnoreCase))
                {
                    throw new NoStackException(
                        $"Access denied: The path '{filePath}' resolves to a directory outside the current project scope.\n" +
                        $"Current project: {projectName} ({absoluteProjectRoot})\n" +
                        $"For security reasons, ssotme can only access files within the project directory.");
                }
            }
            catch (NoStackException)
            {
                // Re-throw our custom exceptions
                throw;
            }
            catch (Exception ex)
            {
                // Handle path resolution errors
                throw new NoStackException($"Error validating path '{filePath}': {ex.Message}");
            }
        }

        private void ImportFile(string filePattern, FileSet fs)
        {
            var fileNameReplacement = String.Empty;
            if (filePattern.Contains("="))
            {
                fileNameReplacement = filePattern.Substring(0, filePattern.IndexOf("="));
                filePattern = filePattern.Substring(filePattern.IndexOf("=") + 1);
            }

            // Validate that the file path is within project scope before processing
            var projectRoot = this.AICaptureProject?.RootPath;
            var directoryPath = Path.GetDirectoryName(filePattern);
            if (!String.IsNullOrEmpty(directoryPath))
            {
                var name = "unknown";
                if (!ReferenceEquals(this.AICaptureProject, null))
                {
                    name = this.AICaptureProject.Name;
                }
                ValidatePathIsInProjectScope(directoryPath, name, projectRoot);
            }

            var di = new DirectoryInfo(Path.Combine(".", Path.GetDirectoryName(filePattern)));
            filePattern = Path.GetFileName(filePattern);

            var matchingFiles = new FileInfo[] { };
            if (di.Exists)
            {
                matchingFiles = di.GetFiles(filePattern);
            }
            if (!matchingFiles.Any() && !this.OptionalInputCLIInputs.Contains(filePattern))
            {
                var curColor = Console.ForegroundColor;
                Console.ForegroundColor = ConsoleColor.Yellow;
                Console.WriteLine("\n\nWARNING:\n\n - No INPUT files matched {0} in {1}\n", filePattern, di.FullName);
                var fsf = new FileSetFile();
                fsf.RelativePath = Path.GetFileName(filePattern);
                fs.FileSetFiles.Add(fsf);

                Console.ForegroundColor = curColor;

            }

            foreach (var matchingFileFI in matchingFiles)
            {
                var fsf = new FileSetFile();
                fsf.RelativePath = String.IsNullOrEmpty(fileNameReplacement) ? matchingFileFI.Name : fileNameReplacement;
                var projectRootLength = this.AICaptureProject.RootPath.Length;
                var matchingFileFILength = matchingFileFI.Directory.FullName.Length;
                var minLength = Math.Min(projectRootLength, matchingFileFILength);
                fsf.OriginalRelativePath = matchingFileFI.FullName.Substring(minLength).Replace("\\", "/");
                fs.FileSetFiles.Add(fsf);

                if (matchingFileFI.Exists)
                {
                    if (matchingFileFI.IsBinaryFile())
                    {
                        fsf.ZippedBinaryFileContents = File.ReadAllBytes(matchingFileFI.FullName).Zip();
                    }
                    else
                    {
                        fsf.ZippedFileContents = File.ReadAllText(matchingFileFI.FullName).Zip();
                    }
                }
                else
                {
                    var curColor = Console.ForegroundColor;
                    Console.ForegroundColor = ConsoleColor.Yellow;
                    Console.WriteLine("INPUT Format: {0} did not match any files in {1}", filePattern, di.FullName);
                    Console.ForegroundColor = curColor;
                }
            }
        }

        private void conditionallyPopulateTranspiler(SSOTMEPayload payload, string transpilerName)
        {
            // Always initialize the Transpiler property to avoid NullReferenceException
            if (payload.Transpiler == null)
            {
                payload.Transpiler = new Transpiler();
                
                // Set a name based on the transpiler string if available
                if (!string.IsNullOrEmpty(this.transpiler))
                {
                    payload.Transpiler.Name = this.transpiler;
                }
                else
                {
                    // Use passed transpiler name
                    payload.Transpiler.Name = transpilerName;
                }
            }
        }

        private async void AccountHolder_ReplyTo(object sender, SassyMQ.Lib.RabbitMQ.PayloadEventArgs<SSOTMEPayload> e)
        {
            // Console.WriteLine("DirectMessageQueue: {0},  Exchange: {1}, LexiconTerm: {2}, RoutingKey: {3}, SenderId: {4}", 
            //     e.Payload.DirectMessageQueue, e.Payload.Exchange, e.Payload.LexiconTerm, e.Payload.RoutingKey, e.Payload.SenderId);
            var payload = AccountHolder.CreatePayload();
            payload.SaveCLIOptions(this);
            
            if (e.Payload.IsLexiconTerm(LexiconTermEnum.accountholder_ping_ssotmecoordinator))
            {
                if (!String.IsNullOrEmpty(this.targetUrl) )
                {
                    this.conditionallyPopulateTranspiler(payload, this.transpiler);

                    // Set LowerHyphenName for .zfs file creation after transpiler is populated
                    if (payload.Transpiler != null && !string.IsNullOrEmpty(payload.Transpiler.Name))
                    {
                        if (payload.Transpiler.Name.StartsWith("remote-transpiler") && !string.IsNullOrEmpty(this.targetUrl))
                        {
                            // For remote transpilers, use sanitized URL as the filename
                            var sanitizedUrl = this.targetUrl.SanitizeUrlForFilename();
                            payload.Transpiler.LowerHyphenName = sanitizedUrl;
                            Console.WriteLine($"Setting remote transpiler .zfs name to SANITIZED URL: {sanitizedUrl}");
                        }
                        else
                        {
                            // For other transpilers, derive from name
                            payload.Transpiler.LowerHyphenName = payload.Transpiler.Name.ToTitle().Replace(" ", "-").ToLower();
                            Console.WriteLine($"Setting transpiler .zfs name to DERIVED NAME: {payload.Transpiler.LowerHyphenName}");
                        }
                    }

                    using var client = new HttpClient();
                    payload.TranspileRequest = new TranspileRequest();
                    payload.TranspileRequest.ZippedInputFileSet = this.inputFileSetXml.Zip();
               
                    var response = await client.PostAsJsonAsync($"{this.targetUrl}", payload);
                    if (response != null)
                    {
                        var responseContent = await response.Content.ReadAsStringAsync();
                        var responsePayload = JsonConvert.DeserializeObject<SSOTMEPayload>(responseContent);
                        result = responsePayload;
                        if (result != null)
                        {
                            result.SSoTmeProject = this.AICaptureProject;
                            if (this.clean) result.CleanFileSet();
                            else
                            {
                                var finalResult = result.SaveFileSet(this.skipClean);
                            }
                        }
                    }
                }
                else
                {
                    CoordinatorProxy = new DMProxy(e.Payload.DirectMessageQueue);
                    payload.TranspileRequest = new TranspileRequest();
                    payload.TranspileRequest.ZippedInputFileSet = this.inputFileSetXml.Zip();
                    payload.CLIInputFileContents = String.Empty;
                    AccountHolder.AccountHolderCommandLineTranspile(payload, CoordinatorProxy);
                }
            }
            else if (e.Payload.IsLexiconTerm(LexiconTermEnum.accountholder_commandlinetranspile_ssotmecoordinator) ||
                    (e.Payload.IsLexiconTerm(LexiconTermEnum.accountholder_requesttranspile_ssotmecoordinator)))
            {
                result = e.Payload;
            }
        }

        private async void ProxyRequest()
        {
            var payload = AccountHolder.CreatePayload();
            payload.SaveCLIOptions(this);
            this.conditionallyPopulateTranspiler(payload, this.transpiler);

            // Set LowerHyphenName for .zfs file creation after transpiler is populated
            if (payload.Transpiler != null && !string.IsNullOrEmpty(payload.Transpiler.Name))
            {
                if (payload.Transpiler.Name.StartsWith("remote-transpiler") && !string.IsNullOrEmpty(this.targetUrl))
                {
                    // For remote transpilers, use sanitized URL as the filename
                    var sanitizedUrl = this.targetUrl.SanitizeUrlForFilename();
                    payload.Transpiler.LowerHyphenName = sanitizedUrl;
                    // Console.WriteLine($"Setting remote transpiler .zfs name to SANITIZED URL: {sanitizedUrl}");
                }
                else
                {
                    // For other transpilers, derive from name
                    payload.Transpiler.LowerHyphenName = payload.Transpiler.Name.ToTitle().Replace(" ", "-").ToLower();
                    // Console.WriteLine($"Setting transpiler .zfs name to DERIVED NAME: {payload.Transpiler.LowerHyphenName}");
                }
            }

            using var client = new HttpClient();
            payload.TranspileRequest = new TranspileRequest();
            payload.TranspileRequest.ZippedInputFileSet = this.inputFileSetXml.Zip();
            payload.CLIInputFileContents = string.Empty;

            var response = await client.PostAsJsonAsync($"{this.targetUrl ?? "https://proxy.effortlessapi.com/"}", payload);
            if (response != null)
            {
                var responseContent = await response.Content.ReadAsStringAsync();

                // Check if response is successful
                if (!response.IsSuccessStatusCode)
                {
                    this.result = new SSOTMEPayload
                    {
                        Exception = new Exception($"Proxy request failed with status {response.StatusCode}: {responseContent}")
                    };
                    return;
                }

                // Check if response content looks like JSON
                if (string.IsNullOrWhiteSpace(responseContent) ||
                    (!responseContent.TrimStart().StartsWith("{") && !responseContent.TrimStart().StartsWith("[")))
                {
                    // If response is plain text that might indicate transpiler status
                    if (responseContent.Trim().Equals("True", StringComparison.OrdinalIgnoreCase) ||
                        responseContent.Trim().Equals("False", StringComparison.OrdinalIgnoreCase) ||
                        responseContent.Trim().Contains("transpiler") ||
                        responseContent.Trim().Contains("inactive"))
                    {
                        this.result = new SSOTMEPayload
                        {
                            Exception = new Exception($"Proxy server returned transpiler status message: {responseContent.Trim()}")
                        };
                    }
                    else
                    {
                        this.result = new SSOTMEPayload
                        {
                            Exception = new Exception($"Proxy server returned non-JSON response: {responseContent}")
                        };
                    }
                    return;
                }
                try
                {
                    var responsePayload = JsonConvert.DeserializeObject<SSOTMEPayload>(responseContent);
                    // Debug remote transpiler responses
                    if (!string.IsNullOrEmpty(this.targetUrl) && this.transpiler.StartsWith("remote-transpiler"))
                    {
                        var expectedName = this.transpiler;
                        var returnedName = responsePayload?.Transpiler?.Name ?? "NULL";
                        var hasZippedFileSet = responsePayload?.TranspileRequest?.ZippedOutputFileSet?.Length > 0;
                        if (!returnedName.StartsWith("remote-transpiler"))
                        {
                            Console.WriteLine($"WARNING: Remote server {this.targetUrl} returned unexpected transpiler name.");
                            Console.WriteLine($"  Expected: '{expectedName}' (or similar remote-transpiler name)");
                            Console.WriteLine($"  Received: '{returnedName}'");
                            Console.WriteLine($"  JSON Key: Response should set 'Transpiler.Name' to preserve the original name");
                            Console.WriteLine($"  This will cause the transpiler name to be reset during builds.");
                        }
                        if (!hasZippedFileSet)
                        {
                            Console.WriteLine($"WARNING: Remote server {this.targetUrl} did not return expected output files.");
                            Console.WriteLine($"  JSON Key: Response should set 'TranspileRequest.ZippedOutputFileSet' with generated files");
                            Console.WriteLine($"  This will prevent files from being written to the project.");
                        }
                        else
                        {
                            // Validate ZFS content - check for files with no content
                            try
                            {
                                var zfsBytes = responsePayload?.TranspileRequest?.ZippedOutputFileSet;
                                if (zfsBytes?.Length > 0)
                                {
                                    var fileSetXml = zfsBytes.UnzipToString();
                                    if (!String.IsNullOrEmpty(fileSetXml) && fileSetXml.Contains("<"))
                                    {
                                        fileSetXml = fileSetXml.Substring(fileSetXml.IndexOf("<"));
                                        fileSetXml = fileSetXml.Replace("FileContents><?xml ", "FileContents>&lt;?xml");

                                        var doc = new System.Xml.XmlDocument();
                                        doc.LoadXml(fileSetXml);
                                        var fileSetNodes = doc.SelectNodes("//FileSetFile");

                                        var filesWithNoContent = new List<string>();

                                        foreach (System.Xml.XmlElement fileSetFileElem in fileSetNodes)
                                        {
                                            var relPathElem = fileSetFileElem.SelectSingleNode("RelativePath");
                                            if (relPathElem != null)
                                            {
                                                var fileContentsNode = fileSetFileElem.SelectSingleNode("FileContents");
                                                var zippedFileContents = fileSetFileElem.SelectSingleNode("ZippedTextFileContents");
                                                if (ReferenceEquals(zippedFileContents, null))
                                                {
                                                    zippedFileContents = fileSetFileElem.SelectSingleNode("ZippedFileContents");
                                                }
                                                var binaryFileContentsNode = fileSetFileElem.SelectSingleNode("BinaryFileContents");

                                                bool hasContent = (!ReferenceEquals(fileContentsNode, null) && !String.IsNullOrEmpty(fileContentsNode.InnerXml)) ||
                                                                (!ReferenceEquals(zippedFileContents, null) && !String.IsNullOrEmpty(zippedFileContents.InnerXml)) ||
                                                                (!ReferenceEquals(binaryFileContentsNode, null) && !String.IsNullOrEmpty(binaryFileContentsNode.InnerText));

                                                if (!hasContent)
                                                {
                                                    filesWithNoContent.Add(relPathElem.InnerText);
                                                }
                                            }
                                        }

                                        if (filesWithNoContent.Any())
                                        {
                                            Console.WriteLine($"WARNING: ZFS contains file entries with no content:");
                                            foreach (var file in filesWithNoContent)
                                            {
                                                Console.WriteLine($"  - {file}");
                                            }
                                            Console.WriteLine($"  Files without content cannot be properly cleaned during 'ssotme clean'");
                                            Console.WriteLine($"  This may indicate the transpiler is not generating complete file entries");
                                        }
                                    }
                                }
                            }
                            catch (Exception ex)
                            {
                                Console.WriteLine($"WARNING: Error validating ZFS content: {ex.Message}");
                            }
                        }
                    }
                    this.result = responsePayload;
                }
                catch (JsonException ex)
                {
                    this.result = new SSOTMEPayload
                    {
                        Exception = new Exception($"Failed to parse proxy response as JSON. Status: {response.StatusCode}, Content-Type: {response.Content.Headers.ContentType}, Response content: {responseContent}", ex)
                    };
                }
            }
            else
            {
                this.result = new SSOTMEPayload
                {
                    Exception = new Exception("No response received from proxy server")
                };
            }
        }

        private bool ShouldAutoBuildForInstall()
        {
            // Parse command line to check for -i flag, similar to ProjectTranspiler constructor logic
            var lowerCLI = Environment.CommandLine.ToLower().Replace("\\", "/");
            var cmd0 = Environment.CommandLine;

            // Remove common prefixes to get the actual transpiler command
            if (lowerCLI.Contains("/ssotme.exe")) cmd0 = cmd0.Substring(lowerCLI.IndexOf("/ssotme.exe") + "/ssotme.exe".Length);
            else if (lowerCLI.Contains("/ssotme.ost.cli.dll")) cmd0 = cmd0.Substring(lowerCLI.IndexOf("/ssotme.ost.cli.dll") + "/ssotme.ost.cli.dll".Length);
            else if (lowerCLI.Contains("/aicapture.ost.cli.dll")) cmd0 = cmd0.Substring(lowerCLI.IndexOf("/aicapture.ost.cli.dll") + "/aicapture.ost.cli.dll".Length);
            else if (lowerCLI.Contains("/ssotme")) cmd0 = cmd0.Substring(lowerCLI.IndexOf("/ssotme") + "/ssotme".Length);
            else if (lowerCLI.Contains("/aicapture")) cmd0 = cmd0.Substring(lowerCLI.IndexOf("/aicapture") + "/aicapture".Length);
            else if (lowerCLI.Contains("/aic")) cmd0 = cmd0.Substring(lowerCLI.IndexOf("/aic") + "/aic".Length);

            cmd0 = cmd0.Trim(" '\"".ToCharArray());

            // Remove install prefixes
            if (cmd0.StartsWith("/ssotme ")) cmd0 = cmd0.Substring("/ssotme ".Length);
            if (cmd0.StartsWith("install ")) cmd0 = cmd0.Substring("install ".Length);
            if (cmd0.StartsWith("-install ")) cmd0 = cmd0.Substring("-install ".Length);
            if (cmd0.StartsWith("ssotme ")) cmd0 = cmd0.Substring("ssotme ".Length);

            // Check if the cleaned command line contains -i flag
            var args = cmd0.Split(' ');
            var iIndex = Array.IndexOf(args, "-i");

            if (iIndex == -1 || iIndex + 1 >= args.Length)
            {
                // No -i flag or no filename after -i
                return false;
            }

            // Get the filename specified after -i
            var inputFileName = args[iIndex + 1];

            // Check if the input file already exists
            var inputFilePath = Path.Combine(Environment.CurrentDirectory, inputFileName);
            if (File.Exists(inputFilePath))
            {
                // Input file exists, no need to build
                return false;
            }

            // Input file doesn't exist and -i flag is present, should auto-build
            return true;
        }
    }
}
