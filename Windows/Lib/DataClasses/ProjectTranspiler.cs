/*******************************************
 Initially Generated by SSoT.me - codee42 & odxml42
 Created By: EJ Alexandra - 2017
             An Abstract Level, llc
 License:    Mozilla Public License 2.0
 *******************************************/
using System;
using System.Collections.Generic;
using System.ComponentModel;
using SassyMQ.SSOTME.Lib.RMQActors;
using System.IO;
using System.Diagnostics;
using SSoTme.OST.Lib.CLIOptions;
using SSoTme.OST.Lib.Extensions;
using SassyMQ.Lib.RabbitMQ;
using System.Text.RegularExpressions;
using System.Linq;
using Newtonsoft.Json;

namespace SSoTme.OST.Lib.DataClasses
{
    public partial class ProjectTranspiler
    {
        [JsonIgnore]
        public Transpiler MatchedTranspiler { get; set; }

        [JsonIgnore]
        public SSoTmeCLIHandler CLIHandler { get; private set; }

        // Fields used by the my.effortlessapi tool marketplace that should get preserved during builds
        // CLI doesn't use these fields, just preserves if they exist
        public string MarketToolName { get; set; }
        public string LastUsed { get; set; }
        public string NumExecutions { get; set; }

        public ProjectTranspiler()
        {
            this.InitPoco();
        }

        // Helper method to check if a command line represents a remote URL transpiler
        private static bool IsRemoteUrlCommandLine(string commandLine)
        {
            if (string.IsNullOrEmpty(commandLine)) return false;

            var trimmedCmd = commandLine.Trim();

            // Check if command starts with http:// or https://
            if (trimmedCmd.StartsWith("http://", StringComparison.OrdinalIgnoreCase) ||
                trimmedCmd.StartsWith("https://", StringComparison.OrdinalIgnoreCase))
            {
                return true;
            }

            // Check if command contains -g flag followed by a URL
            if (trimmedCmd.Contains("-g "))
            {
                var parts = trimmedCmd.Split(' ');
                var gIndex = Array.IndexOf(parts, "-g");
                if (gIndex >= 0 && gIndex + 1 < parts.Length)
                {
                    var nextPart = parts[gIndex + 1];
                    return nextPart.StartsWith("http://", StringComparison.OrdinalIgnoreCase) ||
                           nextPart.StartsWith("https://", StringComparison.OrdinalIgnoreCase);
                }
            }

            return false;
        }

        public bool IsSSoTTranspiler { get; set; }

        public override string ToString()
        {
            var outputFileName = String.Empty;
            if (!ReferenceEquals(this.CLIHandler, null) && !ReferenceEquals(this.CLIHandler.OutputFileSet, null))
            {
                var outputFileSet = this.CLIHandler.OutputFileSet;
                if (!ReferenceEquals(outputFileSet, null) && System.Linq.Enumerable.Any(outputFileSet.FileSetFiles))
                {
                    outputFileName = String.Format(" ({0})", System.Linq.Enumerable.First(outputFileSet.FileSetFiles).RelativePath);
                }
            }
            var files = String.Format("{0}{1}", this.RelativePath, outputFileName).PadRight(40);
            return String.Format("{0} :: {1}", files, this.CommandLine);
        }

        public ProjectTranspiler(string relativePath, SSOTMEPayload result)
        : this()
        {
            bool localCommand = (ReferenceEquals(result, null));

            this.Name = localCommand ? "LocalCommand" : result.Transpiler.Name;

            this.RelativePath = relativePath.SafeToString().Replace("\\", "/");
            var lowerCLI = Environment.CommandLine.ToLower().Replace("\\", "/");
            var cmd0 = Environment.CommandLine;
            if (lowerCLI.Contains("/ssotme.exe")) cmd0 = cmd0.Substring(lowerCLI.IndexOf("/ssotme.exe") + "/ssotme.exe".Length);
            else if (lowerCLI.Contains("/ssotme.ost.cli.dll")) cmd0 = cmd0.Substring(lowerCLI.IndexOf("/ssotme.ost.cli.dll") + "/ssotme.ost.cli.dll".Length);
            else if (lowerCLI.Contains("/aicapture.ost.cli.dll")) cmd0 = cmd0.Substring(lowerCLI.IndexOf("/aicapture.ost.cli.dll") + "/aicapture.ost.cli.dll".Length);            
            else if (lowerCLI.Contains("/ssotme")) cmd0 = cmd0.Substring(lowerCLI.IndexOf("/ssotme") + "/ssotme".Length);
            else if (lowerCLI.Contains("/aicapture")) cmd0 = cmd0.Substring(lowerCLI.IndexOf("/aicapture") + "/aicapture".Length);
            else if (lowerCLI.Contains("/aic")) cmd0 = cmd0.Substring(lowerCLI.IndexOf("/aic") + "/aic".Length);

            // some common errors - on install we should remove all these prefixes from the CommandLine in the json
            cmd0 = cmd0.Trim(" '\"".ToCharArray());
            if (cmd0.StartsWith("/ssotme ")) {
                cmd0 = cmd0.Substring("/ssotme ".Length);
            }
            if (cmd0.StartsWith("install ")) {
                cmd0 = cmd0.Substring("install ".Length);
            }
            if (cmd0.StartsWith("-install ")) {
                cmd0 = cmd0.Substring("-install ".Length);
            }
            if (cmd0.StartsWith("ssotme ")) {
                cmd0 = cmd0.Substring("ssotme ".Length);
            }
            cmd0 = cmd0.Trim(" '\"".ToCharArray());
            Console.WriteLine($"COMMAND LINE: {cmd0}");
            this.CommandLine = cmd0;
            this.MatchedTranspiler = localCommand ? default(Transpiler) : result.Transpiler;
        }

        internal void Rebuild(SSoTmeProject project, bool debugOption)
        {
            // Build command line with debug flag if needed, but don't mutate this.CommandLine
            var commandLineToRun = this.CommandLine;
            if (debugOption)
            {
                commandLineToRun += " -debug";
            }

            Console.WriteLine("\n\n **** " + this.RelativePath + ": " + this.Name + " ****");
            Console.WriteLine("CommandLine:> ssotme {0}", commandLineToRun);
            var transpileRootDI = new DirectoryInfo(Path.Combine(project.RootPath, $"{this.RelativePath}".Trim("\\/".ToCharArray())));
            if (!transpileRootDI.Exists) transpileRootDI.Create();

            // Store original directory to restore later
            var originalDirectory = Environment.CurrentDirectory;
            try
            {
                Environment.CurrentDirectory = transpileRootDI.FullName;

                // Create handler and set the project BEFORE parsing
                // This ensures ImportFile() uses the correct project root
                var cliHandler = new SSoTmeCLIHandler();
                cliHandler.AICaptureProject = project;
                cliHandler.commandLine = commandLineToRun;  // Use the modified command line, not this.CommandLine
                cliHandler.ParseCommand();

                var cliResult = cliHandler.TranspileProject(this);
                if (cliResult != 0) throw new Exception("Error RE-Transpiling");
            }
            finally
            {
                Environment.CurrentDirectory = originalDirectory;
            }
        }

        internal void Clean(SSoTmeProject project, bool preserveZFS, bool debug = false)
        {
            Console.WriteLine("CLEANING: " + this.RelativePath + ": " + this.Name);
            Console.WriteLine("CommandLine:> ssotme {0}", this.CommandLine);
            var di = new DirectoryInfo(Path.Combine(project.RootPath, this.RelativePath.Trim("\\/".ToCharArray())));
            if (!di.Exists) di.Create();
            Environment.CurrentDirectory = di.FullName;
            var zfsDI = project.GetZFSDI(this.RelativePath);

            // Derive transpiler name from command line (not from saved JSON)
            // For remote transpilers, extract and sanitize the URL from command line
            string transpilerName = SSoTmeProject.LowerHyphenName(this.Name);
            if (IsRemoteUrlCommandLine(this.CommandLine))
            {
                // Extract URL from command line - handle both "-g URL" and direct "URL" syntax
                var trimmedCmd = this.CommandLine.Trim();
                string targetUrl = null;

                if (trimmedCmd.StartsWith("http://", StringComparison.OrdinalIgnoreCase) ||
                    trimmedCmd.StartsWith("https://", StringComparison.OrdinalIgnoreCase))
                {
                    // Direct URL syntax: extract URL as first word
                    var parts = trimmedCmd.Split(' ');
                    targetUrl = parts[0];
                }
                else if (trimmedCmd.Contains("-g "))
                {
                    // "-g URL" syntax: extract URL after -g flag
                    var parts = this.CommandLine.Split(' ');
                    var gIndex = Array.IndexOf(parts, "-g");
                    if (gIndex >= 0 && gIndex + 1 < parts.Length)
                    {
                        targetUrl = parts[gIndex + 1];
                    }
                }

                if (!string.IsNullOrEmpty(targetUrl))
                {
                    transpilerName = targetUrl.SanitizeUrlForFilename();
                }
            }

            String zsfFileName = String.Format("{0}/{1}.zfs", zfsDI.FullName, transpilerName);
            var zfsFI = new FileInfo(zsfFileName);
            if (zfsFI.Exists)
            {
                var zippedFileSet = File.ReadAllBytes(zfsFI.FullName);
                if (debug) Console.WriteLine($"DEBUG: Read {zippedFileSet.Length} bytes from {zfsFI.FullName}, calling CleanZippedFileSet()");
                zippedFileSet.CleanZippedFileSet(debug);
                if (debug) Console.WriteLine($"DEBUG: CleanZippedFileSet() completed");
                if (!preserveZFS)
                {
                    File.Delete(zfsFI.FullName);
                }
            }
        }

        public void Describe(SSoTmeProject project)
        { 
            Console.WriteLine("\n-----------------------------------");
            Console.WriteLine("---- {0}{1}", this.Name, this.IsDisabled ? "    **** DISABLED ****" : "");
            Console.WriteLine("---- .{0}/", $"{this.RelativePath}".Replace("\\", "/"));
            Console.WriteLine("-----------------------------------");
            Console.WriteLine("\nCommand Line:> ssotme {0}\n", this.CommandLine);
        }

        public bool IsAtPath(string relativePath, bool exactMatch = false)
        {
            // Normalize paths - trim leading/trailing slashes and convert to lowercase
            relativePath = relativePath.Replace("\\", "/").Trim('/').ToLower();
            var transpilerPath = this.RelativePath
                                   .SafeToString()
                                   .Replace("\\", "/")
                                   .Trim('/')
                                   .ToLower();

            // If checking from project root
            if (string.IsNullOrEmpty(relativePath))
            {
                // For exact match, only match transpilers at root (empty path)
                if (exactMatch) return string.IsNullOrEmpty(transpilerPath);
                // For non-exact match, all transpilers match
                return true;
            }

            // If transpiler is at root but we're in a subdirectory, no match
            if (string.IsNullOrEmpty(transpilerPath)) return false;

            // For exact match, only check equality
            if (exactMatch) return transpilerPath == relativePath;

            // For non-exact match, check if transpiler path starts with or equals the relative path
            return transpilerPath.StartsWith(relativePath) || transpilerPath == relativePath;
        }

        public void LoadInputAndOuputFiles(SSoTmeProject project, bool includeContents)
        {

            var cliHandler = SSoTmeCLIHandler.CreateHandler(this.CommandLine);
            if (!includeContents)
            {
                foreach (var fsf in cliHandler.FileSet.FileSetFiles)
                {
                    fsf.ClearContents();
                }
                cliHandler.inputFileSetXml = String.Empty;
                cliHandler.AICaptureProject = null;
            }

            // Derive transpiler name from command line (not from saved JSON)
            string transpilerName = SSoTmeProject.LowerHyphenName(this.Name);
            if (IsRemoteUrlCommandLine(this.CommandLine))
            {
                // Extract URL from command line - handle both "-g URL" and direct "URL" syntax
                var trimmedCmd = this.CommandLine.Trim();
                string targetUrl = null;

                if (trimmedCmd.StartsWith("http://", StringComparison.OrdinalIgnoreCase) ||
                    trimmedCmd.StartsWith("https://", StringComparison.OrdinalIgnoreCase))
                {
                    // Direct URL syntax: extract URL as first word
                    var parts = trimmedCmd.Split(' ');
                    targetUrl = parts[0];
                }
                else if (trimmedCmd.Contains("-g "))
                {
                    // "-g URL" syntax: extract URL after -g flag
                    var parts = this.CommandLine.Split(' ');
                    var gIndex = Array.IndexOf(parts, "-g");
                    if (gIndex >= 0 && gIndex + 1 < parts.Length)
                    {
                        targetUrl = parts[gIndex + 1];
                    }
                }

                if (!string.IsNullOrEmpty(targetUrl))
                {
                    transpilerName = targetUrl.SanitizeUrlForFilename();
                }
            }

            cliHandler.AICaptureProject = project;
            cliHandler.LoadOutputFiles(transpilerName, this.GetProjectRelativePath(project), includeContents);
            cliHandler.AICaptureProject = null;

            this.CLIHandler = cliHandler;
        }

        public String GetProjectRelativePath(SSoTmeProject project)
        {
            var fullPath = Path.Combine(project.RootPath, this.RelativePath.Trim("\\/".ToCharArray()));
            return fullPath.Substring(project.RootPath.Length).Replace("\\", "/");
        }
    }
}