/*******************************************
 Initially Generated by SSoT.me - codee42 & odxml42
 Created By: EJ Alexandra - 2017
             An Abstract Level, llc
 License:    Mozilla Public License 2.0
 *******************************************/
using System;
using System.Text;
using System.ComponentModel;
using SassyMQ.SSOTME.Lib.RMQActors;
using System.IO;
using Newtonsoft.Json;
using SassyMQ.Lib.RabbitMQ;
using System.Linq;
using SSoTme.OST.Lib.Extensions;
using System.Xml;
using System.Diagnostics;
using System.Collections.Generic;
//using System.Windows.Forms;
using System.Threading;
using EnumList;
using Newtonsoft.Json.Linq;
using System.Threading.Tasks;
using System.Runtime.CompilerServices;
using SSoTme.OST.Core.Lib.Extensions;
using System.Net.Http;
using System.Text.Json;

namespace SSoTme.OST.Lib.DataClasses
{
    public partial class SSoTmeProject
    {
        public List<string> HiddenPaths { get; set; }
        public List<string> ExpandedPaths { get; set; }
        public bool ShowHidden { get; set; }
        private string _currentPath;
        public bool ShowAllFiles { get; set; }
        public string CurrentPath
        {
            get => _currentPath;
            set
            {
                if (!String.Equals(_currentPath, value, StringComparison.OrdinalIgnoreCase))
                {
                    if (String.IsNullOrEmpty(_currentPath) || !String.IsNullOrEmpty(value))
                    {
                        _currentPath = value;
                        this.OnCurrentPathChanged(EventArgs.Empty);
                    }
                }
            }
        }
        private FileSystemWatcher _projectMonitor;

        protected FileSystemWatcher ProjectMonitor
        {
            get => _projectMonitor;
            set
            {
                if (!ReferenceEquals(_projectMonitor, null)) this.UnwireProjectMonitor();
                _projectMonitor = value;
                if (!ReferenceEquals(_projectMonitor, null)) this.WireProjectMonitor();
            }
        }

        private bool SaveDisabled { get; set; }
        public List<string> SSoTmeProjectFiles { get; private set; }

        private void WireProjectMonitor()
        {
            this.ProjectMonitor.IncludeSubdirectories = true;
            this.ProjectMonitor.EnableRaisingEvents = true;
            this.ProjectMonitor.Changed += ProjectMonitor_Changed;
            this.ProjectMonitor.NotifyFilter = this.ProjectMonitor.NotifyFilter | NotifyFilters.LastAccess;
        }

        public void DisableSave()
        {
            this.SaveDisabled = true;
        }

        public void EnableSave()
        {
            this.SaveDisabled = false;
        }

        private void ProjectMonitor_Changed(object sender, FileSystemEventArgs e)
        {
            if (String.Equals(Path.GetFileName(e.FullPath), "ssotme.json", StringComparison.OrdinalIgnoreCase))
            {
                //var form = Application.OpenForms.OfType<Form>().FirstOrDefault();
                //if (ReferenceEquals(form, null) || !form.InvokeRequired) this.OnProjectFileReloaded(this, e);
                //else
                //{
                //    try
                //    {
                //        form.Invoke(new EventHandler<FileSystemEventArgs>(this.OnProjectFileReloaded), this, e);
                //    }
                //    catch (ObjectDisposedException ode)
                //    {
                //        // ignore disposed errors...
                //    }
                //}
            }
        }

        public event EventHandler<FileSystemEventArgs> ProjectFileReloaded;
        protected virtual void OnProjectFileReloaded(object sender, FileSystemEventArgs e)
        {
            if (!ReferenceEquals(this.ProjectFileReloaded, null))
            {
                this.ProjectFileReloaded(sender, e);
            }
        }

        private void UnwireProjectMonitor()
        {
            this.ProjectMonitor.Changed -= ProjectMonitor_Changed;
        }

        public event EventHandler CurrentPathChanged;
        protected virtual void OnCurrentPathChanged(EventArgs eventArgs)
        {
            if (!ReferenceEquals(this.CurrentPathChanged, null))
            {
                this.CurrentPathChanged(this, eventArgs);
            }
        }

        public SSoTmeProject()
        {
            this.HiddenPaths = new List<String>();
            this.ExpandedPaths = new List<String>();
            this.SaveDisabled = false;
            this.InitPoco();
        }

        public static void Init(bool force = false, String projectName = "")
        {
            var currentDirectoryFI = new DirectoryInfo(Environment.CurrentDirectory);

            FileInfo projectFI = GetProjectFIAt(currentDirectoryFI, false);

            if (projectFI.Exists)
            {
                var currentProject = TryToLoad(currentDirectoryFI);
                if (!ReferenceEquals(currentProject, null) && !force)
                {
                    if (!String.IsNullOrEmpty(projectName))
                    {
                        currentProject.Name = projectName.SafeToString().Replace(" ", "");
                        currentProject.Save();
                    }
                    else throw new Exception(String.Format("Project has already been initialized in: {0}", currentProject.RootPath));
                }
                else throw new Exception("Project not loaded - even though the file exists.  This is unexpected");
            }
            else
            {
                projectName = String.IsNullOrEmpty(projectName) ? Path.GetFileName(Environment.CurrentDirectory) : projectName;
                var newProject = new SSoTmeProject();
                newProject.RootPath = Environment.CurrentDirectory;
                newProject.Name = projectName;
                newProject.AddGitIgnore();
                newProject.Save();
            }

            var ssotFI = new FileInfo(Path.Combine(Environment.CurrentDirectory, "SSoT", "single-source-of-truth.json"));
            if (!ssotFI.Directory.Exists) ssotFI.Directory.Create();
            if (!ssotFI.Exists) File.WriteAllText(ssotFI.FullName, $"{{\"project\":\n  {{\n    \"name\":\"{projectName}\"\n  }}\n}}");
        }

        private void AddGitIgnore()
        {
            var fi = new FileInfo(Path.Combine(this.RootPath, ".gitignore"));
            if (!fi.Exists)
            {
                var gitIgnore = @"/**/obj/**/*
/**/bin/**/*
/**/.ssotme/**/*
/**/DSPXml/**/*
/SSoT/__patch.json
/**/.vs/**/*
/**/node_modules/**/*
/**/.vscode/**/*";

                File.WriteAllText(fi.FullName, gitIgnore);
            }
        }

        public bool IsExpanded(DirectoryInfo directoryToCheck)
        {
            var relativePath = this.GetProjectRelativePath(directoryToCheck);
            return this.ExpandedPaths.Contains(relativePath);

        }

        public void Expand(DirectoryInfo directoryInfo)
        {
            if (!this.IsExpanded(directoryInfo))
            {
                var relativePath = this.GetProjectRelativePath(directoryInfo);
                this.ExpandedPaths.Add(relativePath);
                this.Save();
            }

        }

        public void Collapse(DirectoryInfo directoryInfo)
        {
            if (this.IsExpanded(directoryInfo))
            {
                var relativePath = this.GetProjectRelativePath(directoryInfo);
                while (this.ExpandedPaths.Any(anyPath => anyPath.Equals(relativePath)))
                {
                    this.ExpandedPaths.Remove(relativePath);
                }
            }
        }

        public bool IsHidden(DirectoryInfo directoryInfo)
        {
            return this.HiddenPaths.Contains(this.GetProjectRelativePath(directoryInfo));
        }

        public void ShowNode(DirectoryInfo directoryInfo)
        {
            var relativePath = this.GetProjectRelativePath(directoryInfo);
            this.HiddenPaths.Remove(relativePath);
            this.LogMessage("Directory Shown {0}", relativePath);
        }

        public class LogEventArgs : EventArgs
        {
            public LogEventArgs(String message, params object[] args)
            {
                this.Message = String.Format(message, args);
            }

            public string Message { get; }
        }

        public event EventHandler<LogEventArgs> MessageLogged;
        public void LogMessage(string formatString, params object[] args)
        {
            Console.WriteLine(formatString, args);

            if (!ReferenceEquals(this.MessageLogged, null))
            {
                this.MessageLogged(this, new LogEventArgs(formatString, args));
            }

        }

        public void HideNode(DirectoryInfo directoryInfo)
        {
            var relativePath = this.GetProjectRelativePath(directoryInfo);
            this.HiddenPaths.Add(relativePath);
            this.LogMessage("Directory Hidden {0}", relativePath);
        }

        public void Save()
        {
            if (this.SaveDisabled) throw new Exception("Saving is currently disabled...");
            this.Save(new DirectoryInfo(this.RootPath));
            // this.LogMessage("Project saved");
        }

        private void Save(DirectoryInfo rootDI)
        {
            this.RemoveUUIds();
            this.AddSetting(string.Format("project-name={0}", this.Name));
            this.ProjectTranspilers
                .ToList()
                .ForEach(feProjectTranspiler =>
                {
                    if (feProjectTranspiler.MatchedTranspiler == null) feProjectTranspiler.MatchedTranspiler = new Transpiler();
                    feProjectTranspiler.MatchedTranspiler = new Transpiler()
                    {
                        TranspilerId = feProjectTranspiler.MatchedTranspiler.TranspilerId,
                        Name = feProjectTranspiler.MatchedTranspiler.Name,
                        Description = feProjectTranspiler.MatchedTranspiler.Description,
                        TranspileRequests = null,
                        TranspilerInstances = null,
                        TranspilerVersions = null
                    };
                });
            string projectJson = JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
            var tempTranspiler = JsonConvert.DeserializeObject<SSoTmeProject>(projectJson);
            tempTranspiler.RootPath = null;
            if (!ReferenceEquals(tempTranspiler.ExpandedPaths, null) &&
                    !tempTranspiler.ExpandedPaths.Any()) tempTranspiler.ExpandedPaths = null;
            if (!ReferenceEquals(tempTranspiler.HiddenPaths, null) &&
                    !tempTranspiler.HiddenPaths.Any()) tempTranspiler.HiddenPaths = null;
            projectJson = JsonConvert.SerializeObject(tempTranspiler, Newtonsoft.Json.Formatting.Indented, new JsonSerializerSettings()
            {
                NullValueHandling = NullValueHandling.Ignore
            });
            projectJson = $"{projectJson}{Environment.NewLine}";
            var count = 0;
            while (count < 5)
            {
                try
                {
                    File.WriteAllText(this.GetProjectFileName(false), projectJson);
                    break;
                }
                catch (System.IO.IOException ioex)
                {
                    count++;
                    Thread.Sleep(500);
                }
            }
        }

        public void RemoveUUIds()
        {
            this.SSoTmeProjectId = Guid.Empty;
            this.ProjectSettings.ToList().ForEach(setting =>
            {
                setting.ProjectSettingId = Guid.Empty;
            });

            this.ProjectTranspilers.ToList().ForEach(transpiler =>
            {
                if (transpiler != null)
                {
                    transpiler.ProjectTranspilerId = Guid.Empty;
                    if (transpiler.MatchedTranspiler != null)
                    {
                        transpiler.MatchedTranspiler.TranspilerId = Guid.Empty;
                    }
                }
            });
        }

        protected String GetProjectFileName(bool reverseUpdate)
        {
            return GetProjectFI(reverseUpdate).FullName;
        }

        protected FileInfo GetProjectFI(bool reverseUpdate)
        {
            return GetProjectFIAt(new DirectoryInfo(this.RootPath), reverseUpdate);
        }

        protected static FileInfo GetProjectFIAt(DirectoryInfo rootDI, bool reverseUpdate)
        {
            var aiCaptureProjectFI = new FileInfo(Path.Combine(rootDI.FullName, "ssotme.json"));
            var defaultFI = aiCaptureProjectFI;

            if (!aiCaptureProjectFI.Exists)
            {
                aiCaptureProjectFI = new FileInfo(Path.Combine(rootDI.FullName, "aicapture.json"));
                if (!aiCaptureProjectFI.Exists)
                {
                    aiCaptureProjectFI = new FileInfo(Path.Combine(rootDI.FullName, "SSoTmeProject.json"));
                }
            }

            var ssotmeProjectFI = (aiCaptureProjectFI.Exists ? aiCaptureProjectFI : defaultFI);
            if (!(ssotmeProjectFI is null))
            {
                var task = Task.Run(() => ssotmeProjectFI.Directory.ApplySeedReplacementsAsync(reverseUpdate));
                try
                {
                    task.Wait();
                    if (!(task.Exception is null)) throw task.Exception;
                }
                catch (Exception ex)
                {
                    throw new ThreadInterruptedException($"Error applying seed replacments....{ex.Message}", ex);
                }
            }

            return ssotmeProjectFI;
        }

        private static AICaptureProject Load(FileInfo projectFI, DirectoryInfo requestDirectory = null, bool updateCurrent = true)
        {
            var count = 0;
            while (count++ < 10)
            {
                try
                {
                    var projectJson = File.ReadAllText(projectFI.FullName);
                    var ssotmeProject = JsonConvert.DeserializeObject<AICaptureProject>(projectJson);
                    ssotmeProject.RootPath = projectFI.Directory.FullName;
                    if (String.IsNullOrEmpty(ssotmeProject.Name))
                    {
                        ssotmeProject.Name = Path.GetFileName(ssotmeProject.RootPath);
                    }

                    if (updateCurrent) ssotmeProject.SetCurrentFromRequestDirectory(requestDirectory);

                    return ssotmeProject;

                }
                catch (IOException ioex)
                {
                    Thread.Sleep(500);
                }
            }

            throw new Exception("Unable to load project file: " + projectFI.FullName);

        }

        public void MonitorProjectFile()
        {
            var projectFI = this.GetProjectFI(false);
            if (projectFI.Exists)
            {
                this.ProjectMonitor = new FileSystemWatcher(projectFI.Directory.FullName);
                //this.ProjectMonitor.Filter = "SSoTmeProject.json";
            }
            else this.ProjectMonitor = null;

        }

        public void StopMonitoringProjectFile()
        {
            this.ProjectMonitor = null;
        }

        private void SetCurrentFromRequestDirectory(DirectoryInfo requestDirectory)
        {
            this.CurrentPath = this.GetProjectRelativePath(requestDirectory);
        }

        public static SSoTmeProject LoadOrFail(DirectoryInfo dirToCheck, bool updateCurrent = true, bool reverseUpdate = false)
        {
            var proj = TryToLoad(dirToCheck, dirToCheck, updateCurrent, reverseUpdate);

            //if (ReferenceEquals(proj, null))
            //{
            //    throw new Exception(String.Format("SSoT.me Project file could not be found in {0}.  \n\nPlease run `>ssotme -init` from the root of your project to initialize the SSoTme Project.", dirToCheck.FullName));
            //}
            //else 
            return proj;
        }

        internal DirectoryInfo GetZFSDI(string relativePath)
        {
            var ssotmeDI = (DirectoryInfo)this.GetSSoTmeDI();
            var zfsDI = new DirectoryInfo(Path.Combine(ssotmeDI.FullName, relativePath.Trim("\\/".ToCharArray())));
            if (!zfsDI.Exists) zfsDI.Create();
            return zfsDI;
        }

        private DirectoryInfo GetSSoTmeDI()
        {
            var ssotmeDI = new DirectoryInfo(Path.Combine(this.RootPath, ".ssotme"));
            if (ssotmeDI.Exists)
            {
                ssotmeDI.Create();
                ssotmeDI.Attributes = FileAttributes.Directory | FileAttributes.Hidden;
            }
            return ssotmeDI;

        }

        public static AICaptureProject TryToLoad(DirectoryInfo dirToCheck, DirectoryInfo requestDirectory = null, bool updateCurrent = true, bool reverseUpdate = false)
        {
            FileInfo projectFI = GetProjectFIAt(dirToCheck, reverseUpdate);

            if (ReferenceEquals(requestDirectory, null)) requestDirectory = dirToCheck;

            if (projectFI.Exists) return SSoTmeProject.Load(projectFI, requestDirectory, updateCurrent);
            else
            {
                // Try parent
                if (ReferenceEquals(dirToCheck.Parent, null)) return default(AICaptureProject);
                else return TryToLoad(dirToCheck.Parent, requestDirectory, updateCurrent);
            }
        }

        public void AddSetting(string setting)
        {
            var partsOfSetting = setting.SafeToString().Split("=".ToCharArray(), StringSplitOptions.RemoveEmptyEntries);

            var settingName = partsOfSetting.FirstOrDefault();
            var settingValue = String.Join(String.Empty, partsOfSetting.Skip(1));

            if (string.IsNullOrEmpty(settingName)) throw new Exception("Settings must be in the format of 'name=value'");
            else
            {
                var currentSettings = this.ProjectSettings.Where(whereSetting => String.Equals(whereSetting.Name, settingName, StringComparison.OrdinalIgnoreCase));

                var addSetting = true;

                if ((currentSettings.Count() == 1) && (currentSettings.First().Value == settingValue))
                {
                    addSetting = false;
                }

                if (addSetting)
                {
                    currentSettings.ToList().ForEach(feSettingToRemove => this.ProjectSettings.Remove(feSettingToRemove));

                    this.ProjectSettings.Add(new ProjectSetting()
                    {
                        Name = settingName,
                        Value = settingValue
                    });
                    this.LogMessage("Added Setting: {0}: '{1}'", settingName, settingValue);
                }

                if (String.Equals(settingName, "project-name", StringComparison.OrdinalIgnoreCase))
                {
                    if (!String.IsNullOrEmpty(settingValue) && (settingValue != this.Name)) this.Name = settingValue;
                }
            }
        }

        internal void ListSettings()
        {
            this.LogMessage("\nSETTINGS: ");

            if (this.ProjectSettings.Any())
            {
                foreach (var projectSetting in this.ProjectSettings)
                {
                    this.LogMessage("    - {0} = {1}", projectSetting.Name, projectSetting.Value);
                }
            }
            else this.LogMessage("NO settings added to the project yet.");
        }

        private void CheckResults()
        {

            this.LogMessage("Updating transpilers/inputs/outputs and project flow...");

            // Load each tranpspiler and load it's input and output files.
            foreach (var projectTranspiler in this.ProjectTranspilers)
            {
                var ptDI = new DirectoryInfo(Path.Combine(this.RootPath, projectTranspiler.RelativePath.Trim("\\/".ToCharArray())));
                if (!ptDI.Exists) ptDI.Create();
                Environment.CurrentDirectory = Path.Combine(this.RootPath, projectTranspiler.RelativePath.Trim("\\/".ToCharArray()));

                projectTranspiler.LoadInputAndOuputFiles(this, false);
            }

            var json = JsonConvert.SerializeObject(this);
            json = String.Format("{{ \"{0}\" : {1} }}", this.GetName(), json);
            var xml = json.JsonToXml();
            DirectoryInfo di = new DirectoryInfo(Path.Combine(this.RootPath, "DSPXml"));
            if (!di.Exists) di.Create();
            var count = 0;

            while (count < 5)
            {
                try
                {
                    File.WriteAllText(Path.Combine(di.FullName, "SSoTmeProject.spxml"), xml.OuterXml);
                    break;
                }
                catch (System.IO.IOException ioex)
                {
                    count++;
                    Thread.Sleep(500);
                }
            }
        }

        public void CreateDocs(bool checkResults)
        {
            this.LogMessage("Updating Docs from latest SPXml results.");

            if (checkResults)
            {
                this.CheckResults();


                DirectoryInfo di = new DirectoryInfo(Path.Combine(this.RootPath, "DSPXml"));
                if (!di.Exists) di.Create();

                Environment.CurrentDirectory = di.FullName;

                ProcessStartInfo psi = new ProcessStartInfo("cmd");
                psi.WorkingDirectory = di.FullName;

                psi.Arguments = "/C ssotme spxml-to-detailed-spxml -i \"./SSoTmeProject.spxml\"";
                var p = Process.Start(psi);
                p.WaitForExit(100000);
                if (!p.HasExited) throw new Exception("Failed waiting for Detailed SP Xml to be created.");
                else
                {
                    psi.Arguments = "/C ssotme detailed-spxml-to-html-docs -i \"./SSoTmeProject.dspxml\"";
                    p = Process.Start(psi);

                    p.WaitForExit(100000);
                    if (!p.HasExited) throw new Exception("Failed waiting for Docs to be created.");
                    else
                    {
                        this.LogMessage("Analyze completed");
                    }
                }
            }
        }

        public string GetName()
        {
            if (String.IsNullOrEmpty(this.Name)) return Path.GetFileName(this.RootPath);
            else return this.Name;
        }

        public void Describe(string relativePath = "")
        {
            this.LogMessage("\n==========================================");
            this.LogMessage("======  {0}", this.Name);
            this.LogMessage("======    {0}", this.RootPath);
            this.LogMessage("==========================================");

            this.LogMessage(String.Empty);

            this.ListSettings();

            this.LogMessage(String.Empty);


            this.LogMessage("\nTRANSPILERS: ");
            var matchingProjectTranspilers = this.ProjectTranspilers.ToList();

            if (!String.IsNullOrEmpty(relativePath))
            {
                relativePath = this.GetProjectRelativePath(relativePath);
                matchingProjectTranspilers = matchingProjectTranspilers.Where(wherePT => wherePT.IsAtPath(relativePath)).ToList();
            }

            foreach (var projectTranspiler in matchingProjectTranspilers)
            {
                projectTranspiler.Describe(this);
            }
        }

        public void Install(SSOTMEPayload result, string transpilerGroup)
        {
            string relativePath = this.GetProjectRelativePath(Environment.CurrentDirectory);

            var projectTranspiler = new ProjectTranspiler(relativePath, result);
            projectTranspiler.TranspilerGroup = transpilerGroup;

            this.IntegrateNewTranspiler(projectTranspiler);

            this.Save();
        }

        internal void Update(ProjectTranspiler projectTranspiler, SSOTMEPayload result)
        {
            projectTranspiler.MatchedTranspiler = ReferenceEquals(result, null) ? default(Transpiler) : result.Transpiler;
            this.IntegrateExistingTranspiler(projectTranspiler);

            this.Save();
        }

        public string GetProjectRelativePath(DirectoryInfo di)
        {
            if (ReferenceEquals(di, null)) return "/";
            else return this.GetProjectRelativePath(di.FullName);
        }

        public string GetProjectRelativePath(String fullPath)
        {
            var relativePathDI = new DirectoryInfo(fullPath);
            var rootPathDI = new DirectoryInfo(this.RootPath);
            var relativePath = relativePathDI.FullName.Substring(rootPathDI.FullName.Length);
            return relativePath.Replace("\\", "/");
        }

        internal void RebuildAll(string rootPath, bool includeDisabled, string transpilerGroup, string buildOnTrigger, bool copilotConnect, bool isLocalBuild)
        {
            this.Rebuild(rootPath, includeDisabled, transpilerGroup, buildOnTrigger, copilotConnect, isLocalBuild, true);
        }

        internal void Rebuild(
            string buildPath,
            bool includeDisabled,
            string transpilerGroup,
            string buildOnTrigger,
            bool copilotConnect,
            bool isBuildLocal,
            bool isBuildAll = false)
        {
            if (!string.IsNullOrEmpty(buildOnTrigger))
            {
                this.LogMessage("Watching for Airtable changes using baseId: {0}...", buildOnTrigger);
                this.ListenForChangesAndRebuild(buildPath, includeDisabled, transpilerGroup, isBuildLocal, isBuildAll, buildOnTrigger, copilotConnect);
            }
            else
            {
                this.DoRebuild(buildPath, includeDisabled, transpilerGroup, isBuildLocal, isBuildAll);
            }
        }
        
        private (bool, string) GetLastCopilotRequestedRead(string readReqUri)
        {
            using (var httpClient = new HttpClient())
            {
                string response = httpClient.GetStringAsync(readReqUri).Result;
                var json = JsonDocument.Parse(response);
                var changed = json.RootElement.GetProperty("changed").GetRawText();
                return (changed == "true", response);
            }
        }

        private string PostDataToBridge(JToken data, string uri)
        {
            using (var httpClient = new HttpClient())
            {
                try
                {
                    var jsonString = data.ToString(Newtonsoft.Json.Formatting.None);
                    Console.WriteLine($"Posting to bridge: {uri} - {data}");
                    var content = new StringContent(jsonString, Encoding.UTF8, "application/json");
                    var response = httpClient.PostAsync(uri, content).Result;

                    if (response.IsSuccessStatusCode)
                    {
                        return response.Content.ReadAsStringAsync().Result;
                    }
                    else
                    {
                        this.LogMessage("Error posting data to bridge: {0} - {1}", response.StatusCode, response.ReasonPhrase);
                        return null;
                    }
                }
                catch (Exception ex)
                {
                    this.LogMessage("Exception posting data to bridge: {0}", ex.Message);
                    return null;
                }
            }
        }
        
        private JToken TransformTableDataWithFields(JToken tableData, JToken tableSchema)
        {
            var transformedRows = new JArray();
            
            if (tableData != null && tableData["results"] != null)
            {
                var fields = tableSchema?["fields"]?.ToObject<JArray>();
                var fieldMap = new Dictionary<string, (string name, int id)>();
                
                // Build field mapping from schema
                if (fields != null)
                {
                    foreach (var field in fields)
                    {
                        var fieldId = field["id"]?.ToString();
                        var fieldName = field["name"]?.ToString();
                        if (!string.IsNullOrEmpty(fieldId) && !string.IsNullOrEmpty(fieldName))
                        {
                            fieldMap[$"field_{fieldId}"] = (fieldName, int.Parse(fieldId));
                        }
                    }
                }
                
                foreach (var row in tableData["results"])
                {
                    var transformedRow = new JObject();
                    
                    // Copy basic properties
                    if (row["id"] != null) transformedRow["id"] = row["id"];
                    if (row["order"] != null) transformedRow["order"] = row["order"];
                    
                    // Transform field data
                    foreach (var property in row.ToObject<JObject>().Properties())
                    {
                        if (property.Name.StartsWith("field_") && fieldMap.ContainsKey(property.Name))
                        {
                            var (columnName, fieldId) = fieldMap[property.Name];
                            transformedRow[property.Name] = new JObject
                            {
                                ["columnName"] = columnName,
                                ["value"] = property.Value,
                                ["id"] = fieldId
                            };
                        }
                        else if (!property.Name.Equals("id") && !property.Name.Equals("order"))
                        {
                            // Keep non-field properties as-is
                            transformedRow[property.Name] = property.Value;
                        }
                    }
                    
                    transformedRows.Add(transformedRow);
                }
            }
            
            return new JObject
            {
                ["results"] = transformedRows
            };
        }
        
        private JToken RunCopilotAction(string commandData, string baseId)
        {  // todo you can make undo/redo actions using the baserow 'ClientSessionId' header
            
            var validActions = new[] { "list_tables", "update_field", "get_table_fields", "create_column", "update_field"};
            try
            {
                // get baserow client from ~/.ssotme/ssotme.key file -> "baserow" api
                var baserowClient = new SSoTme.OST.Core.Lib.External.BaserowBackend();
                var requestedChanges = JsonConvert.DeserializeObject<dynamic>(commandData);
                
                Console.WriteLine($"Running Copilot Action: {commandData} on base: {baseId}");
                
                // match copilot's requested action to the right baserow endpoint
                string tableId = requestedChanges.tableId;
                if (requestedChanges.action != "list_tables" && string.IsNullOrEmpty(tableId)) {
                    return new JObject
                    {
                        ["content"] = null,
                        ["msg"] = "Error applying changes: This endpoint requires the tableId field"
                    };
                }
                if (requestedChanges.action != "list_tables" && requestedChanges.tableId == null) {
                    return new JObject
                    {
                        ["content"] = null,
                        ["msg"] = "Error applying changes: table ID was null!"
                    };
                }
                
                string fieldId = requestedChanges.fieldId;
                if (requestedChanges.action == "update_field" && requestedChanges.fieldId == null) {
                    return new JObject
                    {
                        ["content"] = null,
                        ["msg"] = "Error applying changes: this endpoint requires fieldID!"
                    };
                }

                // MARK START action definitions
                if (requestedChanges.action == "list_tables")
                {
                    // table ids are globally unique across all databases
                    this.LogMessage("Fetching tables for base: {0}", baseId);
                    var tablesData = baserowClient.FetchTablesForBase(baseId);
                    return new JObject
                    {
                        ["content"] = tablesData,
                        ["msg"] = $"Successfully retrieved tables for base: {baseId}"
                    };
                }
                else if (requestedChanges.action == "get_table_fields")
                {
                    this.LogMessage("Fetching table data with field mappings for tableId: {0}", tableId);
                    JToken tableData = baserowClient.GetTableData(tableId);
                    JToken tableSchema = baserowClient.GetTableSchema(tableId);
                    
                    // Transform the data to include field objects with columnName, value, and id
                    var transformedData = TransformTableDataWithFields(tableData, tableSchema);
                    
                    return new JObject
                    {
                        ["content"] = transformedData,
                        ["msg"] = $"Successfully retrieved table fields for: {tableId}"
                    };
                }
                else if (requestedChanges.action == "create_column")
                {
                    string name = requestedChanges.content.fieldName;
                    string type = requestedChanges.content.fieldType;
                    Console.WriteLine($"Creating new field: name: {name}, type: {type}");
                    return baserowClient.CreateField(tableId, name, type);
                }
                else if (requestedChanges.action == "get_fields")
                {
                    this.LogMessage("Fetching user-readable table schema for tableId: {0}", tableId);
                    JToken shcema = baserowClient.GetTableSchema(tableId, true);
                    return new JObject
                    {
                        ["content"] = shcema,
                        ["msg"] = $"Successfully retrieved table: {tableId}"
                    };
                }
                else if (requestedChanges.action == "get_field")
                {
                    this.LogMessage($"Fetching field data for id: {fieldId}");
                    JToken fieldResp = baserowClient.GetField(fieldId);
                    return new JObject
                    {
                        ["content"] = fieldResp,
                        ["msg"] = $"Successfully retrieved field: {fieldId}"
                    };
                }
                else if (requestedChanges.action == "update_field")
                {
                    return baserowClient.UpdateField(fieldId, requestedChanges.content);
                }
                else
                {
                    return new JObject
                    {
                        ["content"] = null,
                        ["msg"] = $"Action was not matched to any of the following for base {baseId}: {string.Join(", ", validActions)}"
                    };
                }
            }
            catch (Exception ex)
            {
                this.LogMessage("Error running copilot action: {0}", ex.Message);
                return new JObject
                {
                    ["content"] = null,
                    ["msg"] = $"Error running copilot action: {ex.Message}"
                };
            }
        }
        
        private void ListenForChangesAndRebuild(
    string buildPath,
    bool includeDisabled,
    string transpilerGroup,
    bool isBuildLocal,
    bool isBuildAll,
    string baseId,
    bool isCopilot = false)
        {
            DateTime? lastChangedTime = null;
            bool changeEverDetected = false;
            string uri = $"https://ssotme-cli-airtable-bridge-ahrnz660db6k4.aws-us-east-1.controlplane.us/check?baseId={baseId}";
            string baseCopilotUri = "https://ssotme-cli-airtable-bridge-v2-ahrnz660db6k4.cpln.app/copilot";
            string copilotReadUri = $"{baseCopilotUri}/check-req-actions?baseId={baseId}";
            Console.WriteLine($"Polling {uri} for changes to base: `{baseId}`...");
            if (isCopilot) Console.WriteLine($"Polling {copilotReadUri} for read requests...");
            while (true) {
                if (isCopilot) {
                    var (newCopilotActionRequest, copilotProvidedData) = GetLastCopilotRequestedRead(copilotReadUri);
                    if (newCopilotActionRequest) {
                        Console.WriteLine($"Copilot requested action: {copilotProvidedData}");
                        if (!string.IsNullOrEmpty(copilotProvidedData))
                        {
                            JToken response = RunCopilotAction(copilotProvidedData, baseId);
                            PostDataToBridge(response, $"{baseCopilotUri}/put-action-result?baseId={baseId}");
                        }
                    }
                }

                if (CheckChanged(uri))
                {
                    lastChangedTime = DateTime.UtcNow;
                    changeEverDetected = true;
                    Console.WriteLine($"Change detected at {lastChangedTime.Value.ToLocalTime():HH:mm:ss}");
                }
                else if (changeEverDetected && lastChangedTime.HasValue)
                {
                    var elapsed = (DateTime.UtcNow - lastChangedTime.Value).TotalSeconds;

                    if (elapsed > 10)
                    {
                        Console.WriteLine("No changes in last 10 seconds. Rebuilding...");
                        this.DoRebuild(buildPath, includeDisabled, transpilerGroup, isBuildLocal, isBuildAll);
                        changeEverDetected = false;
                        lastChangedTime = null;
                    }
                    else
                    {
                        Console.WriteLine($"Waiting... {Math.Round(elapsed, 1)}s since last change.");
                    }
                }
                else
                {
                    Console.Write(".");
                }

                Thread.Sleep(3000);
            }
        }

        private bool CheckChanged(string uri)
        {
            try
            {
                using (var httpClient = new HttpClient())
                {
                    var response = httpClient.GetStringAsync(uri).Result;
                    var json = JsonDocument.Parse(response);
                    var changed = json.RootElement.GetProperty("changed").GetRawText();
                    return changed == "true";
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error calling listener API: {ex.Message}");
                return false;
            }
        }


        internal void DoRebuild(string buildPath, bool includeDisabled, string transpilerGroup, bool isBuildLocal, bool isBuildAll = false)
        {
            if (!isBuildLocal) this.CheckIfParentIsRootSeed();
            if (isBuildAll) this.FindSSoTmeJsonFiles();
            var currentDirectory = Environment.CurrentDirectory;
            try
            {
                var relativePath = this.GetProjectRelativePath(buildPath);
                var matchingProjectTranspilers = this.ProjectTranspilers?.Where(wherePT => wherePT.IsAtPath(relativePath)) ?? new List<ProjectTranspiler>();
                matchingProjectTranspilers = matchingProjectTranspilers.Where(wherePT => String.IsNullOrEmpty(transpilerGroup) ||
                                                                                        String.Equals(wherePT.TranspilerGroup, transpilerGroup, StringComparison.OrdinalIgnoreCase));
                foreach (var pt in matchingProjectTranspilers)
                {
                    if (!pt.IsDisabled || includeDisabled) pt.Rebuild(this);
                    else this.LogMessage("\n\n - SKIPPING DISABLED TRANSPILER: {0}\n - {1}\n - {2}\n\n", pt.Name, pt.RelativePath, pt.CommandLine);
                }
                if (isBuildAll) this.BuildSubSSoTmeProjects();
            }
            finally
            {
                Environment.CurrentDirectory = currentDirectory;
            }
        }

        private void BuildSubSSoTmeProjects()
        {
            foreach (var ssotmeProj in this.SSoTmeProjectFiles)
            {
                this.RebuildProjectFile(ssotmeProj);
            }
        }

        private void CleanSubSSoTmeProjects()
        {
            foreach (var ssotmeProj in this.SSoTmeProjectFiles)
            {
                this.CleanProjectFile(ssotmeProj);
            }
        }

        private void CleanProjectFile(string ssotmeProj)
        {
            // Get the directory from the provided file path
            string directory = Path.GetDirectoryName(ssotmeProj);
            var di = new DirectoryInfo(directory);
            di.InvokeSSoTmeClean();
        }


        private void RebuildProjectFile(string ssotmeProj)
        {
            // Get the directory from the provided file path
            string directory = Path.GetDirectoryName(ssotmeProj);
            var di = new DirectoryInfo(directory);
            di.InvokeSSoTmeBuild();
        }

        private void FindSSoTmeJsonFiles()
        {
            this.SSoTmeProjectFiles = new List<string>();
            var currentDir = new DirectoryInfo(Environment.CurrentDirectory);
            this.FindSubSSoTmeJsonFiles(currentDir);
        }

        private void CheckDirectory(DirectoryInfo di)
        {
            var ssotmeJsonFile = di.GetFiles().FirstOrDefault(fi => fi.Name == "ssotme.json");
            if (!(ssotmeJsonFile is null)) this.SSoTmeProjectFiles.Add(ssotmeJsonFile.FullName);
        }

        private void FindSubSSoTmeJsonFiles(DirectoryInfo currentDir)
        {
            foreach (var subDirToCheck in currentDir.GetDirectories())
            {
                if (subDirToCheck.IsIgnored()) continue;
                this.CheckDirectory(subDirToCheck);
            }
            foreach (var subDirToCheck in currentDir.GetDirectories())
            {
                this.FindSubSSoTmeJsonFiles(subDirToCheck);
            }
        }

        private void CheckIfParentIsRootSeed()
        {
            if (File.Exists("../ssotme.json"))
            {
                var p = Process.Start(new ProcessStartInfo("cmd.exe", $"/c ssotme -buildLocal -tg ssot") { WorkingDirectory = ".." });
                p.WaitForExit(300000);
            }
        }

        public void CleanAll(bool preserveZFS)
        {
            var rootPathDI = new DirectoryInfo(this.RootPath);
            this.Clean(rootPathDI.FullName, preserveZFS, true);
            this.RemoveEmptyFolders(rootPathDI.FullName);
        }

        public void Clean(string pathFullName, bool preserveZFS, bool cleanAll = false)
        {
            var currentDirectory = Environment.CurrentDirectory;
            if (cleanAll) this.FindSSoTmeJsonFiles();
            try
            {
                var relativePath = this.GetProjectRelativePath(pathFullName);
                var matchingProjectTranspilers = this.ProjectTranspilers.Where(wherePT => wherePT.IsAtPath(relativePath));
                foreach (var pt in matchingProjectTranspilers)
                {
                    pt.Clean(this, preserveZFS);
                }
                if (cleanAll) this.CleanSubSSoTmeProjects();
            }
            finally
            {
                Environment.CurrentDirectory = currentDirectory;
            }
            this.RemoveEmptyFolders(currentDirectory);
        }

        private void RemoveEmptyFolders(string pathToClean)
        {
            var cleanDI = new DirectoryInfo(pathToClean);

            if (!cleanDI.Exists) return;

            var cleanChildDirs = cleanDI.GetDirectories().ToList();

            foreach (var childDir in cleanChildDirs)
            {
                RemoveEmptyFolders(childDir.FullName);

                childDir.Refresh();
                if (!childDir.Exists) continue;

                var dirs = childDir.GetDirectories();
                if (dirs.Any()) continue;

                var files = childDir.GetFiles();
                if (files.Any()) continue;

                childDir.Delete();
            }

            cleanDI.Refresh();
            if (cleanDI.GetDirectories().Any()) return;
            if (cleanDI.GetFiles().Any()) return;

            cleanDI.Delete();
        }


        private void IntegrateExistingTranspiler(ProjectTranspiler projectTranspiler)
        {
            this.IntegrateTranspiler(projectTranspiler, false);
        }

        private void IntegrateNewTranspiler(ProjectTranspiler projectTranspiler)
        {
            this.IntegrateTranspiler(projectTranspiler, true);
        }

        private void IntegrateTranspiler(ProjectTranspiler projectTranspiler, bool addIfMissing)
        {
            ProjectTranspiler matchingTranspiler = FindMatchingTranspiler(projectTranspiler);
            int firstIndex = -1;
            while (!ReferenceEquals(matchingTranspiler, null))
            {
                if (firstIndex == -1) firstIndex = this.ProjectTranspilers.IndexOf(matchingTranspiler);
                this.ProjectTranspilers.Remove(matchingTranspiler);
                matchingTranspiler = FindMatchingTranspiler(projectTranspiler);
            }
            firstIndex = Math.Min(firstIndex, this.ProjectTranspilers.Count);
            if (firstIndex >= 0) this.ProjectTranspilers.Insert(firstIndex, projectTranspiler);
            else if (addIfMissing) this.ProjectTranspilers.Add(projectTranspiler);
            projectTranspiler.Name = projectTranspiler.MatchedTranspiler?.Name ?? "no-transpiler-found";
        }

        private ProjectTranspiler FindMatchingTranspiler(ProjectTranspiler projectTranspiler)
        {
            return this.ProjectTranspilers.FirstOrDefault(fodPT => (fodPT.Name == projectTranspiler.Name) &&
                                                                                     (fodPT.RelativePath == projectTranspiler.RelativePath) &&
                                                                                     (String.Equals(fodPT.TranspilerGroup, projectTranspiler.TranspilerGroup)));
        }

        public void RemoveSetting(string setting)
        {
            var partsOfSetting = setting.SafeToString().Split("=".ToCharArray(), StringSplitOptions.RemoveEmptyEntries);

            var settingName = partsOfSetting.FirstOrDefault();
            var settingValue = String.Join(String.Empty, partsOfSetting.Skip(1));

            if (string.IsNullOrEmpty(settingName)) throw new Exception("Setting name not provided - unable to remove.");
            else
            {
                var matchingSetting = this.ProjectSettings.FirstOrDefault(fodSetting => fodSetting.Name.Equals(settingName, StringComparison.OrdinalIgnoreCase));
                if (ReferenceEquals(matchingSetting, null)) throw new Exception(String.Format("Can't find matching setting: {0}", settingName));
                else
                {
                    this.ProjectSettings.Remove(matchingSetting);
                    this.LogMessage("Successfully Removed Setting: {0}: '{1}'", matchingSetting.Name, matchingSetting.Value);
                }
            }
        }
    }
}
