/*******************************************
 Initially Generated by SSoT.me - codee42 & odxml42
 Created By: EJ Alexandra - 2017
             An Abstract Level, llc
 License:    Mozilla Public License 2.0
 *******************************************/
using System;
using System.Text;
using System.ComponentModel;
using SassyMQ.SSOTME.Lib.RMQActors;
using System.IO;
using Newtonsoft.Json;
using SassyMQ.Lib.RabbitMQ;
using System.Linq;
using SSoTme.OST.Lib.Extensions;
using System.Xml;
using System.Diagnostics;
using System.Collections.Generic;
//using System.Windows.Forms;
using System.Threading;
using System.Runtime.InteropServices;
using EnumList;
using Newtonsoft.Json.Linq;
using System.Threading.Tasks;
using System.Runtime.CompilerServices;
using SSoTme.OST.Core.Lib.Extensions;
using System.Net.Http;
using System.Text.Json;
using SSoTme.OST.Core.Lib.External;
using Formatting = Newtonsoft.Json.Formatting;

namespace SSoTme.OST.Lib.DataClasses
{
    public partial class SSoTmeProject
    {
        public List<string> HiddenPaths { get; set; }
        public List<string> ExpandedPaths { get; set; }
        public bool ShowHidden { get; set; }
        private string _currentPath;
        public bool ShowAllFiles { get; set; }
        public string CurrentPath
        {
            get => _currentPath;
            set
            {
                if (!String.Equals(_currentPath, value, StringComparison.OrdinalIgnoreCase))
                {
                    if (String.IsNullOrEmpty(_currentPath) || !String.IsNullOrEmpty(value))
                    {
                        _currentPath = value;
                        this.OnCurrentPathChanged(EventArgs.Empty);
                    }
                }
            }
        }
        private FileSystemWatcher _projectMonitor;

        protected FileSystemWatcher ProjectMonitor
        {
            get => _projectMonitor;
            set
            {
                if (!ReferenceEquals(_projectMonitor, null)) this.UnwireProjectMonitor();
                _projectMonitor = value;
                if (!ReferenceEquals(_projectMonitor, null)) this.WireProjectMonitor();
            }
        }

        private bool SaveDisabled { get; set; }
        public List<string> SSoTmeProjectFiles { get; private set; }

        private void WireProjectMonitor()
        {
            this.ProjectMonitor.IncludeSubdirectories = true;
            this.ProjectMonitor.EnableRaisingEvents = true;
            this.ProjectMonitor.Changed += ProjectMonitor_Changed;
            this.ProjectMonitor.NotifyFilter = this.ProjectMonitor.NotifyFilter | NotifyFilters.LastAccess;
        }

        public void DisableSave()
        {
            this.SaveDisabled = true;
        }

        public void EnableSave()
        {
            this.SaveDisabled = false;
        }

        private void ProjectMonitor_Changed(object sender, FileSystemEventArgs e)
        {
            if (String.Equals(Path.GetFileName(e.FullPath), "ssotme.json", StringComparison.OrdinalIgnoreCase))
            {
                //var form = Application.OpenForms.OfType<Form>().FirstOrDefault();
                //if (ReferenceEquals(form, null) || !form.InvokeRequired) this.OnProjectFileReloaded(this, e);
                //else
                //{
                //    try
                //    {
                //        form.Invoke(new EventHandler<FileSystemEventArgs>(this.OnProjectFileReloaded), this, e);
                //    }
                //    catch (ObjectDisposedException ode)
                //    {
                //        // ignore disposed errors...
                //    }
                //}
            }
        }

        public event EventHandler<FileSystemEventArgs> ProjectFileReloaded;
        protected virtual void OnProjectFileReloaded(object sender, FileSystemEventArgs e)
        {
            if (!ReferenceEquals(this.ProjectFileReloaded, null))
            {
                this.ProjectFileReloaded(sender, e);
            }
        }

        private void UnwireProjectMonitor()
        {
            this.ProjectMonitor.Changed -= ProjectMonitor_Changed;
        }

        public event EventHandler CurrentPathChanged;
        protected virtual void OnCurrentPathChanged(EventArgs eventArgs)
        {
            if (!ReferenceEquals(this.CurrentPathChanged, null))
            {
                this.CurrentPathChanged(this, eventArgs);
            }
        }

        public SSoTmeProject()
        {
            this.HiddenPaths = new List<String>();
            this.ExpandedPaths = new List<String>();
            this.SaveDisabled = false;
            this.InitPoco();
        }

        public static void Init(bool force = false, String projectName = "")
        {
            var currentDirectoryFI = new DirectoryInfo(Environment.CurrentDirectory);

            FileInfo projectFI = GetProjectFIAt(currentDirectoryFI, false);

            if (projectFI.Exists)
            {
                var currentProject = TryToLoad(currentDirectoryFI);
                if (!ReferenceEquals(currentProject, null) && !force)
                {
                    if (!String.IsNullOrEmpty(projectName))
                    {
                        currentProject.Name = projectName.SafeToString().Replace(" ", "");
                        currentProject.Save();
                    }
                    else throw new Exception(String.Format("Project has already been initialized in: {0}", currentProject.RootPath));
                }
                else throw new Exception("Project not loaded - even though the file exists.  This is unexpected");
            }
            else
            {
                projectName = String.IsNullOrEmpty(projectName) ? Path.GetFileName(Environment.CurrentDirectory) : projectName;
                var newProject = new SSoTmeProject();
                newProject.RootPath = Environment.CurrentDirectory;
                newProject.Name = projectName;
                newProject.AddGitIgnore();
                newProject.Save();
            }

            var ssotFI = new FileInfo(Path.Combine(Environment.CurrentDirectory, "SSoT", "single-source-of-truth.json"));
            if (!ssotFI.Directory.Exists) ssotFI.Directory.Create();
            if (!ssotFI.Exists) File.WriteAllText(ssotFI.FullName, $"{{\"project\":\n  {{\n    \"name\":\"{projectName}\"\n  }}\n}}");
        }

        private void AddGitIgnore()
        {
            var fi = new FileInfo(Path.Combine(this.RootPath, ".gitignore"));
            if (!fi.Exists)
            {
                var gitIgnore = @"/**/obj/**/*
/**/bin/**/*
/**/.ssotme/**/*
/**/DSPXml/**/*
/SSoT/__patch.json
/**/.vs/**/*
/**/node_modules/**/*
/**/.vscode/**/*";

                File.WriteAllText(fi.FullName, gitIgnore);
            }
        }

        public bool IsExpanded(DirectoryInfo directoryToCheck)
        {
            var relativePath = this.GetProjectRelativePath(directoryToCheck);
            return this.ExpandedPaths.Contains(relativePath);

        }

        public void Expand(DirectoryInfo directoryInfo)
        {
            if (!this.IsExpanded(directoryInfo))
            {
                var relativePath = this.GetProjectRelativePath(directoryInfo);
                this.ExpandedPaths.Add(relativePath);
                this.Save();
            }

        }

        public void Collapse(DirectoryInfo directoryInfo)
        {
            if (this.IsExpanded(directoryInfo))
            {
                var relativePath = this.GetProjectRelativePath(directoryInfo);
                while (this.ExpandedPaths.Any(anyPath => anyPath.Equals(relativePath)))
                {
                    this.ExpandedPaths.Remove(relativePath);
                }
            }
        }

        public bool IsHidden(DirectoryInfo directoryInfo)
        {
            return this.HiddenPaths.Contains(this.GetProjectRelativePath(directoryInfo));
        }

        public void ShowNode(DirectoryInfo directoryInfo)
        {
            var relativePath = this.GetProjectRelativePath(directoryInfo);
            this.HiddenPaths.Remove(relativePath);
            this.LogMessage("Directory Shown {0}", relativePath);
        }

        public class LogEventArgs : EventArgs
        {
            public LogEventArgs(String message, params object[] args)
            {
                this.Message = String.Format(message, args);
            }

            public string Message { get; }
        }

        public event EventHandler<LogEventArgs> MessageLogged;
        public void LogMessage(string formatString, params object[] args)
        {
            Console.WriteLine(formatString, args);

            if (!ReferenceEquals(this.MessageLogged, null))
            {
                this.MessageLogged(this, new LogEventArgs(formatString, args));
            }

        }

        public void HideNode(DirectoryInfo directoryInfo)
        {
            var relativePath = this.GetProjectRelativePath(directoryInfo);
            this.HiddenPaths.Add(relativePath);
            this.LogMessage("Directory Hidden {0}", relativePath);
        }

        public void Save()
        {
            if (this.SaveDisabled) throw new Exception("Saving is currently disabled...");
            this.Save(new DirectoryInfo(this.RootPath));
            // this.LogMessage("Project saved");
        }

        private void Save(DirectoryInfo rootDI)
        {
            this.RemoveUUIds();
            this.AddSetting(string.Format("project-name={0}", this.Name));
            // Note: MatchedTranspiler is marked with [JsonIgnore] and won't be serialized
            // The transpiler name will be derived fresh from API responses on each run
            string projectJson = JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
            var tempTranspiler = JsonConvert.DeserializeObject<SSoTmeProject>(projectJson);
            tempTranspiler.RootPath = null;
            if (!ReferenceEquals(tempTranspiler.ExpandedPaths, null) &&
                    !tempTranspiler.ExpandedPaths.Any()) tempTranspiler.ExpandedPaths = null;
            if (!ReferenceEquals(tempTranspiler.HiddenPaths, null) &&
                    !tempTranspiler.HiddenPaths.Any()) tempTranspiler.HiddenPaths = null;
            projectJson = JsonConvert.SerializeObject(tempTranspiler, Newtonsoft.Json.Formatting.Indented, new JsonSerializerSettings()
            {
                NullValueHandling = NullValueHandling.Ignore
            });
            projectJson = $"{projectJson}{Environment.NewLine}";
            var count = 0;
            while (count < 5)
            {
                try
                {
                    File.WriteAllText(this.GetProjectFileName(false), projectJson);
                    break;
                }
                catch (System.IO.IOException ioex)
                {
                    count++;
                    Thread.Sleep(500);
                }
            }
        }

        public void RemoveUUIds()
        {
            this.SSoTmeProjectId = Guid.Empty;
            this.ProjectSettings.ToList().ForEach(setting =>
            {
                setting.ProjectSettingId = Guid.Empty;
            });

            this.ProjectTranspilers.ToList().ForEach(transpiler =>
            {
                if (transpiler != null)
                {
                    transpiler.ProjectTranspilerId = Guid.Empty;
                    // Note: MatchedTranspiler is not saved to JSON (marked with [JsonIgnore])
                }
            });
        }

        protected String GetProjectFileName(bool reverseUpdate)
        {
            return GetProjectFI(reverseUpdate).FullName;
        }

        protected FileInfo GetProjectFI(bool reverseUpdate)
        {
            return GetProjectFIAt(new DirectoryInfo(this.RootPath), reverseUpdate);
        }

        protected static FileInfo GetProjectFIAt(DirectoryInfo rootDI, bool reverseUpdate)
        {
            var aiCaptureProjectFI = new FileInfo(Path.Combine(rootDI.FullName, "ssotme.json"));
            var defaultFI = aiCaptureProjectFI;

            if (!aiCaptureProjectFI.Exists)
            {
                aiCaptureProjectFI = new FileInfo(Path.Combine(rootDI.FullName, "aicapture.json"));
                if (!aiCaptureProjectFI.Exists)
                {
                    aiCaptureProjectFI = new FileInfo(Path.Combine(rootDI.FullName, "SSoTmeProject.json"));
                }
            }

            var ssotmeProjectFI = (aiCaptureProjectFI.Exists ? aiCaptureProjectFI : defaultFI);
            if (!(ssotmeProjectFI is null))
            {
                var task = Task.Run(() => ssotmeProjectFI.Directory.ApplySeedReplacementsAsync(reverseUpdate));
                try
                {
                    task.Wait();
                    if (!(task.Exception is null)) throw task.Exception;
                }
                catch (Exception ex)
                {
                    throw new ThreadInterruptedException($"Error applying seed replacements....{ex.Message}", ex);
                }
            }

            return ssotmeProjectFI;
        }

        private static AICaptureProject Load(FileInfo projectFI, DirectoryInfo requestDirectory = null, bool updateCurrent = true)
        {
            var count = 0;
            while (count++ < 10)
            {
                try
                {
                    var projectJson = File.ReadAllText(projectFI.FullName);
                    var ssotmeProject = JsonConvert.DeserializeObject<AICaptureProject>(projectJson);
                    ssotmeProject.RootPath = projectFI.Directory.FullName;
                    if (String.IsNullOrEmpty(ssotmeProject.Name))
                    {
                        ssotmeProject.Name = Path.GetFileName(ssotmeProject.RootPath);
                    }

                    if (updateCurrent) ssotmeProject.SetCurrentFromRequestDirectory(requestDirectory);

                    return ssotmeProject;

                }
                catch (IOException ioex)
                {
                    Thread.Sleep(500);
                }
            }

            throw new Exception("Unable to load project file: " + projectFI.FullName);

        }

        public void MonitorProjectFile()
        {
            var projectFI = this.GetProjectFI(false);
            if (projectFI.Exists)
            {
                this.ProjectMonitor = new FileSystemWatcher(projectFI.Directory.FullName);
                //this.ProjectMonitor.Filter = "SSoTmeProject.json";
            }
            else this.ProjectMonitor = null;

        }

        public void StopMonitoringProjectFile()
        {
            this.ProjectMonitor = null;
        }

        private void SetCurrentFromRequestDirectory(DirectoryInfo requestDirectory)
        {
            this.CurrentPath = this.GetProjectRelativePath(requestDirectory);
        }

        public static SSoTmeProject LoadOrFail(DirectoryInfo dirToCheck, bool updateCurrent = true, bool reverseUpdate = false)
        {
            var proj = TryToLoad(dirToCheck, dirToCheck, updateCurrent, reverseUpdate);

            //if (ReferenceEquals(proj, null))
            //{
            //    throw new Exception(String.Format("SSoT.me Project file could not be found in {0}.  \n\nPlease run `>ssotme -init` from the root of your project to initialize the SSoTme Project.", dirToCheck.FullName));
            //}
            //else 
            return proj;
        }

        internal DirectoryInfo GetZFSDI(string relativePath)
        {
            var ssotmeDI = (DirectoryInfo)this.GetSSoTmeDI();
            var zfsDI = new DirectoryInfo(Path.Combine(ssotmeDI.FullName, relativePath.Trim("\\/".ToCharArray())));
            if (!zfsDI.Exists) zfsDI.Create();
            return zfsDI;
        }

        public DirectoryInfo GetSSoTmeDI()
        {
            var ssotmeDI = new DirectoryInfo(Path.Combine(this.RootPath, ".ssotme"));
            if (ssotmeDI.Exists)
            {
                ssotmeDI.Create();
                ssotmeDI.Attributes = FileAttributes.Directory | FileAttributes.Hidden;
            }
            return ssotmeDI;

        }

        public static AICaptureProject TryToLoad(DirectoryInfo dirToCheck, DirectoryInfo requestDirectory = null, bool updateCurrent = true, bool reverseUpdate = false)
        {
            FileInfo projectFI = GetProjectFIAt(dirToCheck, reverseUpdate);

            if (ReferenceEquals(requestDirectory, null)) requestDirectory = dirToCheck;

            if (projectFI.Exists) return SSoTmeProject.Load(projectFI, requestDirectory, updateCurrent);
            else
            {
                // Try parent
                if (ReferenceEquals(dirToCheck.Parent, null)) return default(AICaptureProject);
                else return TryToLoad(dirToCheck.Parent, requestDirectory, updateCurrent);
            }
        }

        public void AddSetting(string setting)
        {
            var partsOfSetting = setting.SafeToString().Split("=".ToCharArray(), StringSplitOptions.RemoveEmptyEntries);

            var settingName = partsOfSetting.FirstOrDefault();
            var settingValue = String.Join(String.Empty, partsOfSetting.Skip(1));

            if (string.IsNullOrEmpty(settingName)) throw new Exception("Settings must be in the format of 'name=value'");
            else
            {
                var currentSettings = this.ProjectSettings.Where(whereSetting => String.Equals(whereSetting.Name, settingName, StringComparison.OrdinalIgnoreCase));

                var addSetting = true;

                if ((currentSettings.Count() == 1) && (currentSettings.First().Value == settingValue))
                {
                    addSetting = false;
                }

                if (addSetting)
                {
                    currentSettings.ToList().ForEach(feSettingToRemove => this.ProjectSettings.Remove(feSettingToRemove));

                    this.ProjectSettings.Add(new ProjectSetting()
                    {
                        Name = settingName,
                        Value = settingValue
                    });
                    this.LogMessage("Added Setting: {0}: '{1}'", settingName, settingValue);
                }

                if (String.Equals(settingName, "project-name", StringComparison.OrdinalIgnoreCase))
                {
                    if (!String.IsNullOrEmpty(settingValue) && (settingValue != this.Name)) this.Name = settingValue;
                }
            }
        }

        internal void ListSettings()
        {
            this.LogMessage("\nSETTINGS: ");

            if (this.ProjectSettings.Any())
            {
                foreach (var projectSetting in this.ProjectSettings)
                {
                    this.LogMessage("    - {0} = {1}", projectSetting.Name, projectSetting.Value);
                }
            }
            else this.LogMessage("NO settings added to the project yet.");
        }

        private void CheckResults()
        {

            this.LogMessage("Updating transpilers/inputs/outputs and project flow...");

            // Load each tranpspiler and load it's input and output files.
            foreach (var projectTranspiler in this.ProjectTranspilers)
            {
                var ptDI = new DirectoryInfo(Path.Combine(this.RootPath, projectTranspiler.RelativePath.Trim("\\/".ToCharArray())));
                if (!ptDI.Exists) ptDI.Create();
                Environment.CurrentDirectory = Path.Combine(this.RootPath, projectTranspiler.RelativePath.Trim("\\/".ToCharArray()));

                projectTranspiler.LoadInputAndOuputFiles(this, false);
            }

            var json = JsonConvert.SerializeObject(this);
            json = String.Format("{{ \"{0}\" : {1} }}", this.GetName(), json);
            var xml = json.JsonToXml();
            DirectoryInfo di = new DirectoryInfo(Path.Combine(this.RootPath, "DSPXml"));
            if (!di.Exists) di.Create();
            var count = 0;

            while (count < 5)
            {
                try
                {
                    File.WriteAllText(Path.Combine(di.FullName, "SSoTmeProject.spxml"), xml.OuterXml);
                    break;
                }
                catch (System.IO.IOException ioex)
                {
                    count++;
                    Thread.Sleep(500);
                }
            }
        }

        public void CreateDocs(bool checkResults)
        {
            this.LogMessage("Updating Docs from latest SPXml results.");

            if (checkResults)
            {
                this.CheckResults();


                DirectoryInfo di = new DirectoryInfo(Path.Combine(this.RootPath, "DSPXml"));
                if (!di.Exists) di.Create();

                Environment.CurrentDirectory = di.FullName;

                string proc = RuntimeInformation.IsOSPlatform(OSPlatform.Windows) ? "cmd" : "/bin/bash";
                ProcessStartInfo psi = new ProcessStartInfo(proc);
                psi.WorkingDirectory = di.FullName;

                string c = RuntimeInformation.IsOSPlatform(OSPlatform.Windows) ? "/C " : "-c ";
                psi.Arguments = c + "\"ssotme spxml-to-detailed-spxml -i ./SSoTmeProject.spxml\"";
                var p = Process.Start(psi);
                p.WaitForExit(100000);
                if (!p.HasExited) throw new Exception("Failed waiting for Detailed SP Xml to be created.");
                else
                {
                    psi.Arguments = c + "\"ssotme detailed-spxml-to-html-docs -i ./SSoTmeProject.dspxml\"";
                    p = Process.Start(psi);

                    p.WaitForExit(100000);
                    if (!p.HasExited) throw new Exception("Failed waiting for Docs to be created.");
                    else
                    {
                        this.LogMessage("Analyze completed");
                    }
                }
            }
        }

        public string GetName()
        {
            if (String.IsNullOrEmpty(this.Name)) return Path.GetFileName(this.RootPath);
            else return this.Name;
        }

        public void Describe(string relativePath = "")
        {
            this.LogMessage("\n==========================================");
            this.LogMessage("======  {0}", this.Name);
            this.LogMessage("======    {0}", this.RootPath);
            this.LogMessage("==========================================");

            this.LogMessage(String.Empty);

            this.ListSettings();

            this.LogMessage(String.Empty);


            this.LogMessage("\nTRANSPILERS: ");
            var matchingProjectTranspilers = this.ProjectTranspilers.ToList();

            if (!String.IsNullOrEmpty(relativePath))
            {
                relativePath = this.GetProjectRelativePath(relativePath);
                matchingProjectTranspilers = matchingProjectTranspilers.Where(wherePT => wherePT.IsAtPath(relativePath)).ToList();
            }

            foreach (var projectTranspiler in matchingProjectTranspilers)
            {
                projectTranspiler.Describe(this);
            }
        }

        public void Install(SSOTMEPayload result, string transpilerGroup, bool dryRun)
        {
            string currentDir;
            try
            {
                currentDir = Environment.CurrentDirectory;
            }
            catch (Exception)
            {
                // On macOS, Environment.CurrentDirectory throws if the directory was deleted during cleaning
                // Fall back to the stored path from the payload if available
                currentDir = this.RootPath;
            }
            string relativePath = this.GetProjectRelativePath(currentDir);

            var projectTranspiler = new ProjectTranspiler(relativePath, result);
            projectTranspiler.TranspilerGroup = transpilerGroup;

            this.IntegrateNewTranspiler(projectTranspiler, dryRun);

            this.Save();
        }

        internal void Update(ProjectTranspiler projectTranspiler, SSOTMEPayload result)
        {
            projectTranspiler.MatchedTranspiler = ReferenceEquals(result, null) ? default(Transpiler) : result.Transpiler;
            this.IntegrateExistingTranspiler(projectTranspiler);

            this.Save();
        }

        public string GetProjectRelativePath(DirectoryInfo di)
        {
            if (ReferenceEquals(di, null)) return "/";
            else return this.GetProjectRelativePath(di.FullName);
        }

        public string GetProjectRelativePath(String fullPath)
        {
            var relativePathDI = new DirectoryInfo(fullPath);
            var rootPathDI = new DirectoryInfo(this.RootPath);
            var relativePath = relativePathDI.FullName.Substring(rootPathDI.FullName.Length);
            return relativePath.Replace("\\", "/");
        }

        internal void RebuildAll(string rootPath, bool includeDisabled, string transpilerGroup, string buildOnTrigger, bool copilotConnect, bool isLocalBuild, bool debug)
        {
            this.Rebuild(rootPath, includeDisabled, transpilerGroup, buildOnTrigger, copilotConnect, isLocalBuild, true, debug);
        }

        internal void Rebuild(
            string buildPath,
            bool includeDisabled,
            string transpilerGroup,
            string buildOnTrigger,
            bool copilotConnect,
            bool isBuildLocal,
            bool debug,
            bool isBuildAll = false)
        {
            if (!string.IsNullOrEmpty(buildOnTrigger))
            {
                this.LogMessage("Watching for Airtable changes using baseId: {0}...", buildOnTrigger);
                this.ListenForChangesAndRebuild(buildPath, includeDisabled, transpilerGroup, isBuildLocal, isBuildAll, buildOnTrigger, debug, copilotConnect);
            }
            else
            {
                this.DoRebuild(buildPath, includeDisabled, transpilerGroup, isBuildLocal, debug, isBuildAll);
            }
        }
        
        private void ListenForChangesAndRebuild(
            string buildPath,
            bool includeDisabled,
            string transpilerGroup,
            bool isBuildLocal,
            bool isBuildAll,
            string baseId,
            bool debug,
            bool isCopilot = false)
        {
            DateTime? lastChangedTime = null;
            bool changeEverDetected = false;
            string baseUri = $"https://ssotme-cli-airtable-bridge-ahrnz660db6k4.aws-us-east-1.controlplane.us";
            string baseCopilotUri = "https://ssotme-cli-airtable-bridge-v2-ahrnz660db6k4.cpln.app/copilot";
            //string baseCopilotUri = "http://localhost:8080/copilot";
            Console.WriteLine($"Polling {baseUri}/check?baseId={baseId} for changes to base: `{baseId}`...");

            string microsoftTenantUserId = "test";  // todo actually use the user's microsoft account tenant id somehow
            BOTBridgeServerConnector conn = new BOTBridgeServerConnector(microsoftTenantUserId, baseCopilotUri, baseId);
            
            if (isCopilot)
            {
                Console.WriteLine($"Polling {conn.copilotReadUri} for copilot actions...");
                JToken userBaserowBases = conn.PostAvailableBases();
                if (userBaserowBases == null)
                {
                    throw new Exception("Couldn't post to the remote server");
                }
                else if (!conn.CurrentBaseIdIsAvailable(userBaserowBases))
                {
                    throw new Exception($"You don't have access to any baserow database with ID: {baseId}");
                }
            }
            while (true) {
                if (isCopilot) {
                    var (newCopilotActionRequest, copilotProvidedData, timestamp) = conn.GetLastCopilotRequestedRead();
                    if (newCopilotActionRequest) {
                        if (!string.IsNullOrEmpty(copilotProvidedData))
                        {
                            var (response, success, contentWasUpdated) = conn.RunCopilotAction(copilotProvidedData);
                            conn.PostDataToBridge(response, timestamp, success);
                            if (contentWasUpdated)
                            {
                                conn.PostChange(baseUri);  // signal a rebuild is necessary
                                conn.SetIsBuilding(true);
                            }
                        }
                    }
                }

                if (CheckChanged(baseUri, baseId))
                {
                    lastChangedTime = DateTime.UtcNow;
                    changeEverDetected = true;
                    Console.WriteLine($"Change detected at {lastChangedTime.Value.ToLocalTime():HH:mm:ss}");
                }
                else if (changeEverDetected && lastChangedTime.HasValue)
                {
                    var elapsed = (DateTime.UtcNow - lastChangedTime.Value).TotalSeconds;

                    if (elapsed > 10)
                    {
                        Console.WriteLine("No changes in last 10 seconds. Rebuilding...");
                        try
                        {
                            this.DoRebuild(buildPath, includeDisabled, transpilerGroup, isBuildLocal, debug, isBuildAll);
                        }
                        catch (Exception ex)
                        {
                            Console.WriteLine($"Rebuild failed; {ex.Message}");
                        }
                        
                        if (isCopilot) conn.SetIsBuilding(false);

                        changeEverDetected = false;
                        lastChangedTime = null;
                    }
                    else
                    {
                        Console.WriteLine($"Waiting... {Math.Round(elapsed, 1)}s since last change.");
                    }
                }
                else
                {
                    Console.Write(".");
                }

                Thread.Sleep(3000);
            }
        }

        private bool CheckChanged(string uri, string baseId)
        {
            try
            {
                using (var httpClient = new HttpClient())
                {
                    var response = httpClient.GetStringAsync($"{uri}/check?baseId={baseId}").Result;
                    var json = JsonDocument.Parse(response);
                    var changed = json.RootElement.GetProperty("changed").GetRawText();
                    return changed == "true";
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error calling listener API: {ex.Message}");
                return false;
            }
        }

        internal void DoRebuild(string buildPath, bool includeDisabled, string transpilerGroup, bool isBuildLocal, bool debugOption, bool isBuildAll = false)
        {
            if (!isBuildLocal) this.CheckIfParentIsRootSeed();
            if (isBuildAll) this.FindSSoTmeJsonFiles();
            var currentDirectory = Environment.CurrentDirectory;
            try
            {
                var relativePath = this.GetProjectRelativePath(buildPath);
                var matchingProjectTranspilers = this.ProjectTranspilers?.Where(wherePT => wherePT.IsAtPath(relativePath)) ?? new List<ProjectTranspiler>();
                matchingProjectTranspilers = matchingProjectTranspilers.Where(wherePT => String.IsNullOrEmpty(transpilerGroup) ||
                                                                                        String.Equals(wherePT.TranspilerGroup, transpilerGroup, StringComparison.OrdinalIgnoreCase));
                foreach (var pt in matchingProjectTranspilers)
                {
                    if (!pt.IsDisabled || includeDisabled) pt.Rebuild(this, debugOption);
                    else this.LogMessage("\n\n - SKIPPING DISABLED TRANSPILER: {0}\n - {1}\n - {2}\n\n", pt.Name, pt.RelativePath, pt.CommandLine);
                }
                if (isBuildAll) this.BuildSubSSoTmeProjects();
            }
            finally
            {
                Environment.CurrentDirectory = currentDirectory;
            }
        }

        private void BuildSubSSoTmeProjects()
        {
            foreach (var ssotmeProj in this.SSoTmeProjectFiles)
            {
                this.RebuildProjectFile(ssotmeProj);
            }
        }

        private void CleanSubSSoTmeProjects()
        {
            foreach (var ssotmeProj in this.SSoTmeProjectFiles)
            {
                this.CleanProjectFile(ssotmeProj);
            }
        }

        private void CleanProjectFile(string ssotmeProj)
        {
            // Get the directory from the provided file path
            string directory = Path.GetDirectoryName(ssotmeProj);
            var di = new DirectoryInfo(directory);
            di.InvokeSSoTmeClean();
        }


        private void RebuildProjectFile(string ssotmeProj)
        {
            // Get the directory from the provided file path
            string directory = Path.GetDirectoryName(ssotmeProj);
            var di = new DirectoryInfo(directory);
            di.InvokeSSoTmeBuild();
        }

        private void FindSSoTmeJsonFiles()
        {
            this.SSoTmeProjectFiles = new List<string>();
            var currentDir = new DirectoryInfo(Environment.CurrentDirectory);
            this.FindSubSSoTmeJsonFiles(currentDir);
        }

        private void CheckDirectory(DirectoryInfo di)
        {
            var ssotmeJsonFile = di.GetFiles().FirstOrDefault(fi => fi.Name == "ssotme.json");
            if (!(ssotmeJsonFile is null)) this.SSoTmeProjectFiles.Add(ssotmeJsonFile.FullName);
        }

        private void FindSubSSoTmeJsonFiles(DirectoryInfo currentDir)
        {
            foreach (var subDirToCheck in currentDir.GetDirectories())
            {
                if (subDirToCheck.IsIgnored()) continue;
                this.CheckDirectory(subDirToCheck);
            }
            foreach (var subDirToCheck in currentDir.GetDirectories())
            {
                this.FindSubSSoTmeJsonFiles(subDirToCheck);
            }
        }

        private void CheckIfParentIsRootSeed()
        {
            if (File.Exists("../ssotme.json"))
            {
                ProcessStartInfo psi;
                if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
                {
                    psi = new ProcessStartInfo("cmd.exe", $"/c ssotme -buildLocal -tg ssot") { WorkingDirectory = ".." };
                }
                else
                {
                    psi = new ProcessStartInfo("/bin/bash", $"-c \"ssotme -buildLocal -tg ssot\"") { WorkingDirectory = ".." };
                }
                var p = Process.Start(psi);
                p.WaitForExit(300000);
            }
        }

        public void CleanAll(bool preserveZFS, bool purge, bool debugOption)
        {
            var rootPathDI = new DirectoryInfo(this.RootPath);
            this.Clean(rootPathDI.FullName, preserveZFS, purge, debugOption, true);
            this.RemoveEmptyFolders(rootPathDI.FullName);
        }

        private void RemoveUnusedZFSFiles(bool debug)
        {
            try
            {
                var ssotmeDI = this.GetSSoTmeDI();
                if (!ssotmeDI.Exists) return;

                // Get all existing ZFS files
                var allZfsFiles = ssotmeDI.GetFiles("*.zfs", SearchOption.AllDirectories);

                // Build set of expected ZFS filenames from current transpilers
                var expectedZfsFiles = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

                foreach (var pt in this.ProjectTranspilers)
                {
                    // Derive transpiler name from command line (not from saved JSON)
                    // Use same naming logic as ProjectTranspiler.Clean method
                    string transpilerName;
                    if (pt.Name.StartsWith("http") && pt.CommandLine.Contains("-g "))
                    {
                        // Extract and sanitize URL from command line for remote transpilers
                        var parts = pt.CommandLine.Split(' ');
                        var gIndex = Array.IndexOf(parts, "-g");
                        if (gIndex >= 0 && gIndex + 1 < parts.Length)
                        {
                            var targetUrl = parts[gIndex + 1];
                            transpilerName = targetUrl.SanitizeUrlForFilename();
                        }
                        else
                        {
                            transpilerName = pt.Name.ToLower().Replace(" ", "");
                        }
                    }
                    else
                    {
                        // For local transpilers, derive from Name (lowercase with spaces removed)
                        transpilerName = pt.Name.ToLower().Replace(" ", "");
                    }

                    var zfsDI = this.GetZFSDI(pt.RelativePath);
                    var expectedZfsPath = Path.Combine(zfsDI.FullName, $"{transpilerName}.zfs");
                    expectedZfsFiles.Add(expectedZfsPath);
                }

                // Process orphaned ZFS files - clean them first, then remove
                foreach (var zfsFile in allZfsFiles)
                {
                    if (!expectedZfsFiles.Contains(zfsFile.FullName))
                    {
                        if (debug) Console.WriteLine($"Processing orphaned ZFS file: {zfsFile.FullName}");

                        // Extract the relative path from the ZFS file location
                        // ZFS files are stored in .ssotme/{RelativePath}/{transpiler}.zfs
                        var ssotmeDirPath = ssotmeDI.FullName;
                        var zfsFileDir = zfsFile.DirectoryName;
                        var relativePath = zfsFileDir.Substring(ssotmeDirPath.Length).Trim(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar);

                        // Determine the directory to clean from (transpiler's working directory)
                        var transpilerWorkingDir = Path.Combine(this.RootPath, relativePath);
                        var savedCurrentDirectory = Environment.CurrentDirectory;

                        try
                        {
                            // Change to the transpiler's directory before cleaning
                            if (Directory.Exists(transpilerWorkingDir))
                            {
                                Environment.CurrentDirectory = transpilerWorkingDir;
                                if (debug) Console.WriteLine($"DEBUG: Changed to transpiler directory: {transpilerWorkingDir}");
                            }
                            else
                            {
                                if (debug) Console.WriteLine($"DEBUG: Transpiler directory doesn't exist: {transpilerWorkingDir}, using current directory");
                            }

                            // Clean the orphaned ZFS file first
                            var zippedFileSet = File.ReadAllBytes(zfsFile.FullName);
                            if (debug) Console.WriteLine($"DEBUG: Read {zippedFileSet.Length} bytes from orphaned ZFS, calling CleanZippedFileSet()");
                            zippedFileSet.CleanZippedFileSet(debug);
                            if (debug) Console.WriteLine($"DEBUG: CleanZippedFileSet() completed for orphaned ZFS");
                        }
                        catch (Exception ex)
                        {
                            Console.WriteLine($"Warning: Error cleaning orphaned ZFS file {zfsFile.FullName}: {ex.Message}");
                        }
                        finally
                        {
                            // Restore the original directory
                            Environment.CurrentDirectory = savedCurrentDirectory;

                            // Always remove the orphaned ZFS file after cleaning
                            if (debug) Console.WriteLine($"Removing orphaned ZFS file: {zfsFile.FullName}");
                            zfsFile.Delete();
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Warning: Error cleaning unused ZFS files: {ex.Message}");
            }
        }

        public void Clean(string pathFullName, bool preserveZFS, bool purge, bool debugOption, bool cleanAll = false)
        {
            var currentDirectory = Environment.CurrentDirectory;
            if (cleanAll) this.FindSSoTmeJsonFiles();
            try
            {
                var relativePath = this.GetProjectRelativePath(pathFullName);
                var matchingProjectTranspilers = this.ProjectTranspilers.Where(wherePT => wherePT.IsAtPath(relativePath));
                foreach (var pt in matchingProjectTranspilers)
                {
                    pt.Clean(this, preserveZFS, debugOption);
                }
                if (cleanAll) this.CleanSubSSoTmeProjects();
            }
            finally
            {
                Environment.CurrentDirectory = currentDirectory;
            }

            // Remove unused ZFS files (those not corresponding to current transpilers)
            if (!preserveZFS && purge)
            {
                this.RemoveUnusedZFSFiles(debugOption);
            }

            this.RemoveEmptyFolders(currentDirectory);
        }

        private void RemoveEmptyFolders(string pathToClean)
        {
            var cleanDI = new DirectoryInfo(pathToClean);

            if (!cleanDI.Exists) return;

            var cleanChildDirs = cleanDI.GetDirectories().ToList();

            foreach (var childDir in cleanChildDirs)
            {
                RemoveEmptyFolders(childDir.FullName);

                childDir.Refresh();
                if (!childDir.Exists) continue;

                var dirs = childDir.GetDirectories();
                if (dirs.Any()) continue;

                var files = childDir.GetFiles();
                if (files.Any()) continue;

                childDir.Delete();
            }

            cleanDI.Refresh();
            if (cleanDI.GetDirectories().Any()) return;
            if (cleanDI.GetFiles().Any()) return;

            cleanDI.Delete();
        }


        private void IntegrateExistingTranspiler(ProjectTranspiler projectTranspiler)
        {
            this.IntegrateTranspiler(projectTranspiler, false, false);
        }

        private void IntegrateNewTranspiler(ProjectTranspiler projectTranspiler, bool dryRun)
        {
            this.IntegrateTranspiler(projectTranspiler, true, dryRun);
        }

        private void IntegrateTranspiler(ProjectTranspiler projectTranspiler, bool addIfMissing, bool dryRun)
        {
            ProjectTranspiler matchingTranspiler = FindMatchingTranspiler(projectTranspiler);

            if (dryRun)
            {
                Console.WriteLine($"DRY RUN: Installing {projectTranspiler.Name}");
                
                if (matchingTranspiler is null)
                {
                    Console.WriteLine($"DRY RUN: The {projectTranspiler.Name} transpiler will be installed in path {projectTranspiler.RelativePath}");
                }
                else
                {
                    Console.WriteLine($"DRY RUN: The existing {projectTranspiler.Name} transpiler be replaced in path {projectTranspiler.RelativePath}");
                }

                return;
            }
            
            int firstIndex = -1;
            while (!ReferenceEquals(matchingTranspiler, null))
            {
                if (firstIndex == -1) firstIndex = this.ProjectTranspilers.IndexOf(matchingTranspiler);
                this.ProjectTranspilers.Remove(matchingTranspiler);
                matchingTranspiler = FindMatchingTranspiler(projectTranspiler);
            }
            firstIndex = Math.Min(firstIndex, this.ProjectTranspilers.Count);
            if (firstIndex >= 0) this.ProjectTranspilers.Insert(firstIndex, projectTranspiler);
            else if (addIfMissing) this.ProjectTranspilers.Add(projectTranspiler);
            projectTranspiler.Name = projectTranspiler.MatchedTranspiler?.Name.Replace("-", "") ?? "noTranspilerFound";
        }

        private ProjectTranspiler FindMatchingTranspiler(ProjectTranspiler projectTranspiler)
        {
            return this.ProjectTranspilers.FirstOrDefault(fodPT => (fodPT.Name == projectTranspiler.Name) &&
                                                                                     (fodPT.RelativePath == projectTranspiler.RelativePath) &&
                                                                                     (String.Equals(fodPT.TranspilerGroup, projectTranspiler.TranspilerGroup)));
        }

        public void RemoveSetting(string setting)
        {
            var partsOfSetting = setting.SafeToString().Split("=".ToCharArray(), StringSplitOptions.RemoveEmptyEntries);

            var settingName = partsOfSetting.FirstOrDefault();
            var settingValue = String.Join(String.Empty, partsOfSetting.Skip(1));

            if (string.IsNullOrEmpty(settingName)) throw new Exception("Setting name not provided - unable to remove.");
            else
            {
                var matchingSetting = this.ProjectSettings.FirstOrDefault(fodSetting => fodSetting.Name.Equals(settingName, StringComparison.OrdinalIgnoreCase));
                if (ReferenceEquals(matchingSetting, null)) throw new Exception(String.Format("Can't find matching setting: {0}", settingName));
                else
                {
                    this.ProjectSettings.Remove(matchingSetting);
                    this.LogMessage("Successfully Removed Setting: {0}: '{1}'", matchingSetting.Name, matchingSetting.Value);
                }
            }
        }
    }
}
